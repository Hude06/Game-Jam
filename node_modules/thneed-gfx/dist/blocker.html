<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<script>// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles

(function (modules, entry, mainEntry, parcelRequireName, globalName) {
  /* eslint-disable no-undef */
  var globalObject =
    typeof globalThis !== 'undefined'
      ? globalThis
      : typeof self !== 'undefined'
      ? self
      : typeof window !== 'undefined'
      ? window
      : typeof global !== 'undefined'
      ? global
      : {};
  /* eslint-enable no-undef */

  // Save the require from previous bundle to this closure if any
  var previousRequire =
    typeof globalObject[parcelRequireName] === 'function' &&
    globalObject[parcelRequireName];

  var cache = previousRequire.cache || {};
  // Do not use `require` to prevent Webpack from trying to bundle this call
  var nodeRequire =
    typeof module !== 'undefined' &&
    typeof module.require === 'function' &&
    module.require.bind(module);

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire =
          typeof globalObject[parcelRequireName] === 'function' &&
          globalObject[parcelRequireName];
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error("Cannot find module '" + name + "'");
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = (cache[name] = new newRequire.Module(name));

      modules[name][0].call(
        module.exports,
        localRequire,
        module,
        module.exports,
        this
      );
    }

    return cache[name].exports;

    function localRequire(x) {
      var res = localRequire.resolve(x);
      return res === false ? {} : newRequire(res);
    }

    function resolve(x) {
      var id = modules[name][1][x];
      return id != null ? id : x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function (id, exports) {
    modules[id] = [
      function (require, module) {
        module.exports = exports;
      },
      {},
    ];
  };

  Object.defineProperty(newRequire, 'root', {
    get: function () {
      return globalObject[parcelRequireName];
    },
  });

  globalObject[parcelRequireName] = newRequire;

  for (var i = 0; i < entry.length; i++) {
    newRequire(entry[i]);
  }

  if (mainEntry) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(mainEntry);

    // CommonJS
    if (typeof exports === 'object' && typeof module !== 'undefined') {
      module.exports = mainExports;

      // RequireJS
    } else if (typeof define === 'function' && define.amd) {
      define(function () {
        return mainExports;
      });

      // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }
})({"9iQi8":[function(require,module,exports) {
"use strict";
var global = arguments[3];
var HMR_HOST = null;
var HMR_PORT = null;
var HMR_SECURE = false;
var HMR_ENV_HASH = "d6ea1d42532a7575";
module.bundle.HMR_BUNDLE_ID = "3de9700a9848afaa";
/* global HMR_HOST, HMR_PORT, HMR_ENV_HASH, HMR_SECURE, chrome, browser, importScripts */ /*::
import type {
  HMRAsset,
  HMRMessage,
} from '@parcel/reporter-dev-server/src/HMRServer.js';
interface ParcelRequire {
  (string): mixed;
  cache: {|[string]: ParcelModule|};
  hotData: mixed;
  Module: any;
  parent: ?ParcelRequire;
  isParcelRequire: true;
  modules: {|[string]: [Function, {|[string]: string|}]|};
  HMR_BUNDLE_ID: string;
  root: ParcelRequire;
}
interface ParcelModule {
  hot: {|
    data: mixed,
    accept(cb: (Function) => void): void,
    dispose(cb: (mixed) => void): void,
    // accept(deps: Array<string> | string, cb: (Function) => void): void,
    // decline(): void,
    _acceptCallbacks: Array<(Function) => void>,
    _disposeCallbacks: Array<(mixed) => void>,
  |};
}
interface ExtensionContext {
  runtime: {|
    reload(): void,
  |};
}
declare var module: {bundle: ParcelRequire, ...};
declare var HMR_HOST: string;
declare var HMR_PORT: string;
declare var HMR_ENV_HASH: string;
declare var HMR_SECURE: boolean;
declare var chrome: ExtensionContext;
declare var browser: ExtensionContext;
*/ var OVERLAY_ID = "__parcel__error__overlay__";
var OldModule = module.bundle.Module;
function Module(moduleName) {
    OldModule.call(this, moduleName);
    this.hot = {
        data: module.bundle.hotData,
        _acceptCallbacks: [],
        _disposeCallbacks: [],
        accept: function(fn) {
            this._acceptCallbacks.push(fn || function() {});
        },
        dispose: function(fn) {
            this._disposeCallbacks.push(fn);
        }
    };
    module.bundle.hotData = undefined;
}
module.bundle.Module = Module;
var checkedAssets, acceptedAssets, assetsToAccept /*: Array<[ParcelRequire, string]> */ ;
function getHostname() {
    return HMR_HOST || (location.protocol.indexOf("http") === 0 ? location.hostname : "localhost");
}
function getPort() {
    return HMR_PORT || location.port;
} // eslint-disable-next-line no-redeclare
var parent = module.bundle.parent;
if ((!parent || !parent.isParcelRequire) && typeof WebSocket !== "undefined") {
    var hostname = getHostname();
    var port = getPort();
    var protocol = HMR_SECURE || location.protocol == "https:" && !/localhost|127.0.0.1|0.0.0.0/.test(hostname) ? "wss" : "ws";
    var ws = new WebSocket(protocol + "://" + hostname + (port ? ":" + port : "") + "/"); // Safari doesn't support sourceURL in error stacks.
    // eval may also be disabled via CSP, so do a quick check.
    var supportsSourceURL = false;
    try {
        (0, eval)('throw new Error("test"); //# sourceURL=test.js');
    } catch (err) {
        supportsSourceURL = err.stack.includes("test.js");
    } // $FlowFixMe
    ws.onmessage = async function(event) {
        checkedAssets = {} /*: {|[string]: boolean|} */ ;
        acceptedAssets = {} /*: {|[string]: boolean|} */ ;
        assetsToAccept = [];
        var data = JSON.parse(event.data);
        if (data.type === "update") {
            // Remove error overlay if there is one
            if (typeof document !== "undefined") removeErrorOverlay();
            let assets = data.assets.filter((asset)=>asset.envHash === HMR_ENV_HASH); // Handle HMR Update
            let handled = assets.every((asset)=>{
                return asset.type === "css" || asset.type === "js" && hmrAcceptCheck(module.bundle.root, asset.id, asset.depsByBundle);
            });
            if (handled) {
                console.clear(); // Dispatch custom event so other runtimes (e.g React Refresh) are aware.
                if (typeof window !== "undefined" && typeof CustomEvent !== "undefined") window.dispatchEvent(new CustomEvent("parcelhmraccept"));
                await hmrApplyUpdates(assets);
                for(var i = 0; i < assetsToAccept.length; i++){
                    var id = assetsToAccept[i][1];
                    if (!acceptedAssets[id]) hmrAcceptRun(assetsToAccept[i][0], id);
                }
            } else if ("reload" in location) location.reload();
            else {
                // Web extension context
                var ext = typeof chrome === "undefined" ? typeof browser === "undefined" ? null : browser : chrome;
                if (ext && ext.runtime && ext.runtime.reload) ext.runtime.reload();
            }
        }
        if (data.type === "error") {
            // Log parcel errors to console
            for (let ansiDiagnostic of data.diagnostics.ansi){
                let stack = ansiDiagnostic.codeframe ? ansiDiagnostic.codeframe : ansiDiagnostic.stack;
                console.error("\uD83D\uDEA8 [parcel]: " + ansiDiagnostic.message + "\n" + stack + "\n\n" + ansiDiagnostic.hints.join("\n"));
            }
            if (typeof document !== "undefined") {
                // Render the fancy html overlay
                removeErrorOverlay();
                var overlay = createErrorOverlay(data.diagnostics.html); // $FlowFixMe
                document.body.appendChild(overlay);
            }
        }
    };
    ws.onerror = function(e) {
        console.error(e.message);
    };
    ws.onclose = function() {
        console.warn("[parcel] \uD83D\uDEA8 Connection to the HMR server was lost");
    };
}
function removeErrorOverlay() {
    var overlay = document.getElementById(OVERLAY_ID);
    if (overlay) {
        overlay.remove();
        console.log("[parcel] \u2728 Error resolved");
    }
}
function createErrorOverlay(diagnostics) {
    var overlay = document.createElement("div");
    overlay.id = OVERLAY_ID;
    let errorHTML = '<div style="background: black; opacity: 0.85; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; font-family: Menlo, Consolas, monospace; z-index: 9999;">';
    for (let diagnostic of diagnostics){
        let stack = diagnostic.frames.length ? diagnostic.frames.reduce((p, frame)=>{
            return `${p}
<a href="/__parcel_launch_editor?file=${encodeURIComponent(frame.location)}" style="text-decoration: underline; color: #888" onclick="fetch(this.href); return false">${frame.location}</a>
${frame.code}`;
        }, "") : diagnostic.stack;
        errorHTML += `
      <div>
        <div style="font-size: 18px; font-weight: bold; margin-top: 20px;">
          🚨 ${diagnostic.message}
        </div>
        <pre>${stack}</pre>
        <div>
          ${diagnostic.hints.map((hint)=>"<div>\uD83D\uDCA1 " + hint + "</div>").join("")}
        </div>
        ${diagnostic.documentation ? `<div>📝 <a style="color: violet" href="${diagnostic.documentation}" target="_blank">Learn more</a></div>` : ""}
      </div>
    `;
    }
    errorHTML += "</div>";
    overlay.innerHTML = errorHTML;
    return overlay;
}
function getParents(bundle, id) /*: Array<[ParcelRequire, string]> */ {
    var modules = bundle.modules;
    if (!modules) return [];
    var parents = [];
    var k, d, dep;
    for(k in modules)for(d in modules[k][1]){
        dep = modules[k][1][d];
        if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) parents.push([
            bundle,
            k
        ]);
    }
    if (bundle.parent) parents = parents.concat(getParents(bundle.parent, id));
    return parents;
}
function updateLink(link) {
    var newLink = link.cloneNode();
    newLink.onload = function() {
        if (link.parentNode !== null) // $FlowFixMe
        link.parentNode.removeChild(link);
    };
    newLink.setAttribute("href", link.getAttribute("href").split("?")[0] + "?" + Date.now()); // $FlowFixMe
    link.parentNode.insertBefore(newLink, link.nextSibling);
}
var cssTimeout = null;
function reloadCSS() {
    if (cssTimeout) return;
    cssTimeout = setTimeout(function() {
        var links = document.querySelectorAll('link[rel="stylesheet"]');
        for(var i = 0; i < links.length; i++){
            // $FlowFixMe[incompatible-type]
            var href = links[i].getAttribute("href");
            var hostname = getHostname();
            var servedFromHMRServer = hostname === "localhost" ? new RegExp("^(https?:\\/\\/(0.0.0.0|127.0.0.1)|localhost):" + getPort()).test(href) : href.indexOf(hostname + ":" + getPort());
            var absolute = /^https?:\/\//i.test(href) && href.indexOf(location.origin) !== 0 && !servedFromHMRServer;
            if (!absolute) updateLink(links[i]);
        }
        cssTimeout = null;
    }, 50);
}
async function hmrApplyUpdates(assets) {
    global.parcelHotUpdate = Object.create(null);
    let scriptsToRemove;
    try {
        // If sourceURL comments aren't supported in eval, we need to load
        // the update from the dev server over HTTP so that stack traces
        // are correct in errors/logs. This is much slower than eval, so
        // we only do it if needed (currently just Safari).
        // https://bugs.webkit.org/show_bug.cgi?id=137297
        // This path is also taken if a CSP disallows eval.
        if (!supportsSourceURL) {
            let promises = assets.map((asset)=>{
                if (asset.type === "js") {
                    if (typeof document !== "undefined") {
                        let script = document.createElement("script");
                        script.src = asset.url;
                        return new Promise((resolve, reject)=>{
                            var _document$head;
                            script.onload = ()=>resolve(script);
                            script.onerror = reject;
                            (_document$head = document.head) === null || _document$head === void 0 || _document$head.appendChild(script);
                        });
                    } else if (typeof importScripts === "function") return new Promise((resolve, reject)=>{
                        try {
                            importScripts(asset.url);
                        } catch (err) {
                            reject(err);
                        }
                    });
                }
            });
            scriptsToRemove = await Promise.all(promises);
        }
        assets.forEach(function(asset) {
            hmrApply(module.bundle.root, asset);
        });
    } finally{
        delete global.parcelHotUpdate;
        if (scriptsToRemove) scriptsToRemove.forEach((script)=>{
            if (script) {
                var _document$head2;
                (_document$head2 = document.head) === null || _document$head2 === void 0 || _document$head2.removeChild(script);
            }
        });
    }
}
function hmrApply(bundle, asset) {
    var modules = bundle.modules;
    if (!modules) return;
    if (asset.type === "css") reloadCSS();
    else if (asset.type === "js") {
        let deps = asset.depsByBundle[bundle.HMR_BUNDLE_ID];
        if (deps) {
            if (modules[asset.id]) {
                // Remove dependencies that are removed and will become orphaned.
                // This is necessary so that if the asset is added back again, the cache is gone, and we prevent a full page reload.
                let oldDeps = modules[asset.id][1];
                for(let dep in oldDeps)if (!deps[dep] || deps[dep] !== oldDeps[dep]) {
                    let id = oldDeps[dep];
                    let parents = getParents(module.bundle.root, id);
                    if (parents.length === 1) hmrDelete(module.bundle.root, id);
                }
            }
            if (supportsSourceURL) // Global eval. We would use `new Function` here but browser
            // support for source maps is better with eval.
            (0, eval)(asset.output);
            let fn = global.parcelHotUpdate[asset.id];
            modules[asset.id] = [
                fn,
                deps
            ];
        } else if (bundle.parent) hmrApply(bundle.parent, asset);
    }
}
function hmrDelete(bundle, id1) {
    let modules = bundle.modules;
    if (!modules) return;
    if (modules[id1]) {
        // Collect dependencies that will become orphaned when this module is deleted.
        let deps = modules[id1][1];
        let orphans = [];
        for(let dep in deps){
            let parents = getParents(module.bundle.root, deps[dep]);
            if (parents.length === 1) orphans.push(deps[dep]);
        } // Delete the module. This must be done before deleting dependencies in case of circular dependencies.
        delete modules[id1];
        delete bundle.cache[id1]; // Now delete the orphans.
        orphans.forEach((id)=>{
            hmrDelete(module.bundle.root, id);
        });
    } else if (bundle.parent) hmrDelete(bundle.parent, id1);
}
function hmrAcceptCheck(bundle, id, depsByBundle) {
    if (hmrAcceptCheckOne(bundle, id, depsByBundle)) return true;
     // Traverse parents breadth first. All possible ancestries must accept the HMR update, or we'll reload.
    let parents = getParents(module.bundle.root, id);
    let accepted = false;
    while(parents.length > 0){
        let v = parents.shift();
        let a = hmrAcceptCheckOne(v[0], v[1], null);
        if (a) // If this parent accepts, stop traversing upward, but still consider siblings.
        accepted = true;
        else {
            // Otherwise, queue the parents in the next level upward.
            let p = getParents(module.bundle.root, v[1]);
            if (p.length === 0) {
                // If there are no parents, then we've reached an entry without accepting. Reload.
                accepted = false;
                break;
            }
            parents.push(...p);
        }
    }
    return accepted;
}
function hmrAcceptCheckOne(bundle, id, depsByBundle) {
    var modules = bundle.modules;
    if (!modules) return;
    if (depsByBundle && !depsByBundle[bundle.HMR_BUNDLE_ID]) {
        // If we reached the root bundle without finding where the asset should go,
        // there's nothing to do. Mark as "accepted" so we don't reload the page.
        if (!bundle.parent) return true;
        return hmrAcceptCheck(bundle.parent, id, depsByBundle);
    }
    if (checkedAssets[id]) return true;
    checkedAssets[id] = true;
    var cached = bundle.cache[id];
    assetsToAccept.push([
        bundle,
        id
    ]);
    if (!cached || cached.hot && cached.hot._acceptCallbacks.length) return true;
}
function hmrAcceptRun(bundle, id) {
    var cached = bundle.cache[id];
    bundle.hotData = {};
    if (cached && cached.hot) cached.hot.data = bundle.hotData;
    if (cached && cached.hot && cached.hot._disposeCallbacks.length) cached.hot._disposeCallbacks.forEach(function(cb) {
        cb(bundle.hotData);
    });
    delete bundle.cache[id];
    bundle(id);
    cached = bundle.cache[id];
    if (cached && cached.hot && cached.hot._acceptCallbacks.length) cached.hot._acceptCallbacks.forEach(function(cb) {
        var assetsToAlsoAccept = cb(function() {
            return getParents(module.bundle.root, id);
        });
        if (assetsToAlsoAccept && assetsToAccept.length) // $FlowFixMe[method-unbinding]
        assetsToAccept.push.apply(assetsToAccept, assetsToAlsoAccept);
    });
    acceptedAssets[id] = true;
}

},{}],"c3nm2":[function(require,module,exports) {
var _blockerTs = require("./blocker.ts");
(0, _blockerTs.start)();

},{"./blocker.ts":"8cKGl"}],"8cKGl":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "start", ()=>start);
var _src = require("../src");
class Blocker extends (0, _src.LayerView) {
    draw(g) {
        g.fillStandardText("I haz all your pointers!", 100, 100);
    }
    can_receive_mouse() {
        return true;
    }
}
function start() {
    let surface = new (0, _src.CanvasSurface)(640, 480);
    let root = new (0, _src.LayerView)();
    let button = new (0, _src.ActionButton)();
    button.set_caption("can you click me?");
    root.add(button);
    root.add(new Blocker());
    surface.set_root(root);
    surface.addToPage();
    surface.start();
    surface.repaint();
}

},{"../src":"h7u1C","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"h7u1C":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _core = require("./core");
parcelHelpers.exportAll(_core, exports);
var _canvas = require("./canvas");
parcelHelpers.exportAll(_canvas, exports);
var _sprites = require("./sprites");
parcelHelpers.exportAll(_sprites, exports);
var _components = require("./components");
parcelHelpers.exportAll(_components, exports);
var _containers = require("./containers");
parcelHelpers.exportAll(_containers, exports);
var _util = require("./util");
parcelHelpers.exportAll(_util, exports);
var _style = require("./style");
parcelHelpers.exportAll(_style, exports);
var _debug = require("./debug");
parcelHelpers.exportAll(_debug, exports);
var _table = require("./table");
parcelHelpers.exportAll(_table, exports);
console.log("loading thneed");

},{"./core":"6Wpln","./canvas":"1Z0N5","./sprites":"5ouc0","./components":"563zL","./containers":"kfq5H","./util":"7wzGb","./style":"llAwq","./debug":"eaW0r","./table":"lXFYo","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6Wpln":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "CoolEvent", ()=>CoolEvent);
parcelHelpers.export(exports, "POINTER_CATEGORY", ()=>POINTER_CATEGORY);
parcelHelpers.export(exports, "POINTER_MOVE", ()=>POINTER_MOVE);
parcelHelpers.export(exports, "POINTER_DRAG", ()=>POINTER_DRAG);
parcelHelpers.export(exports, "POINTER_DOWN", ()=>POINTER_DOWN);
parcelHelpers.export(exports, "POINTER_UP", ()=>POINTER_UP);
parcelHelpers.export(exports, "PRIMARY_BUTTON", ()=>PRIMARY_BUTTON);
parcelHelpers.export(exports, "SECONDARY_BUTTON", ()=>SECONDARY_BUTTON);
parcelHelpers.export(exports, "gen_id", ()=>gen_id);
parcelHelpers.export(exports, "SuperArray", ()=>SuperArray);
parcelHelpers.export(exports, "Point", ()=>Point);
parcelHelpers.export(exports, "Rect", ()=>Rect);
parcelHelpers.export(exports, "Size", ()=>Size);
parcelHelpers.export(exports, "PointerEvent", ()=>PointerEvent);
parcelHelpers.export(exports, "KEYBOARD_CATEGORY", ()=>KEYBOARD_CATEGORY);
parcelHelpers.export(exports, "KEYBOARD_DOWN", ()=>KEYBOARD_DOWN);
parcelHelpers.export(exports, "KEYBOARD_UP", ()=>KEYBOARD_UP);
parcelHelpers.export(exports, "KeyboardEvent", ()=>KeyboardEvent);
parcelHelpers.export(exports, "SCROLL_CATEGORY", ()=>SCROLL_CATEGORY);
parcelHelpers.export(exports, "SCROLL_EVENT", ()=>SCROLL_EVENT);
parcelHelpers.export(exports, "ScrollEvent", ()=>ScrollEvent);
parcelHelpers.export(exports, "FOCUS_CATEGORY", ()=>FOCUS_CATEGORY);
parcelHelpers.export(exports, "FOCUS_GAINED", ()=>FOCUS_GAINED);
parcelHelpers.export(exports, "FOCUS_LOST", ()=>FOCUS_LOST);
parcelHelpers.export(exports, "FocusEvent", ()=>FocusEvent);
parcelHelpers.export(exports, "COMMAND_CATEGORY", ()=>COMMAND_CATEGORY);
parcelHelpers.export(exports, "COMMAND_ACTION", ()=>COMMAND_ACTION);
parcelHelpers.export(exports, "CommandEvent", ()=>CommandEvent);
parcelHelpers.export(exports, "COMMAND_CHANGE", ()=>COMMAND_CHANGE);
parcelHelpers.export(exports, "CLIPBOARD_CATEGORY", ()=>CLIPBOARD_CATEGORY);
parcelHelpers.export(exports, "CLIPBOARD_COPY", ()=>CLIPBOARD_COPY);
parcelHelpers.export(exports, "CLIPBOARD_CUT", ()=>CLIPBOARD_CUT);
parcelHelpers.export(exports, "CLIPBOARD_PASTE", ()=>CLIPBOARD_PASTE);
parcelHelpers.export(exports, "ClipboardEvent", ()=>ClipboardEvent);
parcelHelpers.export(exports, "BaseParentView", ()=>BaseParentView);
parcelHelpers.export(exports, "BaseView", ()=>BaseView);
parcelHelpers.export(exports, "with_props", ()=>with_props);
parcelHelpers.export(exports, "with_action", ()=>with_action);
parcelHelpers.export(exports, "with_change", ()=>with_change);
class CoolEvent {
    constructor(ctx, category, type){
        this.ctx = ctx;
        this.category = category;
        this.type = type;
    }
}
const POINTER_CATEGORY = "POINTER_CATEGORY";
const POINTER_MOVE = "POINTER_MOVE";
const POINTER_DRAG = "POINTER_DRAG";
const POINTER_DOWN = "POINTER_DOWN";
const POINTER_UP = "POINTER_UP";
const PRIMARY_BUTTON = 0;
const SECONDARY_BUTTON = 2;
function gen_id(prefix) {
    return `${prefix}_${Math.floor(Math.random() * 100000)}`;
}
class SuperArray {
    constructor(){
        this.data = [];
    }
    clear() {
        this.data = [];
    }
    push_end(value) {
        this.data.push(value);
    }
    length() {
        return this.data.length;
    }
    pop_start() {
        return this.data.shift();
    }
    forEach(cb) {
        // @ts-ignore
        this.data.forEach((v, i)=>cb(v, i));
    }
}
class Point {
    constructor(x, y){
        this.x = x;
        this.y = y;
    }
    translate(x, y) {
        return new Point(this.x - x, this.y - y);
    }
    divide_floor(scale) {
        return new Point(Math.floor(this.x / scale), Math.floor(this.y / scale));
    }
    add(pt) {
        return new Point(this.x + pt.x, this.y + pt.y);
    }
    set(x, y) {
        this.x = x;
        this.y = y;
    }
    copy_from(pt) {
        this.x = pt.x;
        this.y = pt.y;
    }
    clone() {
        return new Point(this.x, this.y);
    }
    subtract(trans) {
        return new Point(this.x - trans.x, this.y - trans.y);
    }
    magnitude() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
    }
    divide(val) {
        return new Point(this.x / val, this.y / val);
    }
    scale(val) {
        return new Point(this.x * val, this.y * val);
    }
    unit() {
        return this.divide(this.magnitude());
    }
    toString() {
        return `Point(${this.x},${this.y})`;
    }
}
class Rect {
    constructor(x, y, w, h){
        this.x = x;
        this.y = y;
        this.w = w;
        this.h = h;
    }
    contains(pt) {
        if (pt.x < this.x) return false;
        if (pt.y < this.y) return false;
        if (pt.x >= this.x + this.w) return false;
        if (pt.y >= this.y + this.h) return false;
        return true;
    }
    bottom() {
        return this.y + this.h;
    }
    right() {
        return this.x + this.w;
    }
    shrink(v) {
        return new Rect(this.x + v, this.y + v, this.w - v - v, this.h - v - v);
    }
    position() {
        return new Point(this.x, this.y);
    }
    center() {
        return new Point(this.x + this.w / 2, this.y + this.h / 2);
    }
    add_position(pt) {
        this.x += pt.x;
        this.y += pt.y;
    }
    intersects(rect) {
        if (this.contains(new Point(rect.x, rect.y))) return true;
        if (this.contains(new Point(rect.x, rect.y + rect.h))) return true;
        if (this.contains(new Point(rect.x + rect.w, rect.y))) return true;
        if (this.contains(new Point(rect.x + rect.w, rect.y + rect.h))) return true;
        return false;
    }
}
class Size {
    constructor(w, h){
        this.w = w;
        this.h = h;
    }
    shrink(pad) {
        return new Size(this.w - pad * 2, this.h - pad * 2);
    }
    grow(pad) {
        return new Size(this.w + pad * 2, this.h + pad * 2);
    }
    subtract(delta) {
        return new Size(this.w - delta.x, this.h - delta.y);
    }
    add(delta) {
        return new Size(this.w + delta.x, this.h + delta.y);
    }
    contains(cursor) {
        if (cursor.x < 0) return false;
        if (cursor.y < 0) return false;
        if (cursor.x > this.w) return false;
        if (cursor.y > this.h) return false;
        return true;
    }
    toString() {
        return `${this.w}x${this.h}`;
    }
    equals(s) {
        return this.w === s.w && this.h === s.h;
    }
}
class PointerEvent extends CoolEvent {
    constructor(ctx, type, position, delta){
        super(ctx, POINTER_CATEGORY, type);
        this.position = position;
        this.delta = delta;
        this.direction = "down";
    }
}
const KEYBOARD_CATEGORY = "KEYBOARD_CATEGORY";
const KEYBOARD_DOWN = "KEYBOARD_DOWN";
const KEYBOARD_UP = "KEYBOARD_UP";
class KeyboardEvent extends CoolEvent {
    constructor(surface, type){
        super(surface, KEYBOARD_CATEGORY, type);
    }
}
const SCROLL_CATEGORY = "SCROLL_CATEGORY";
const SCROLL_EVENT = "SCROLL_EVENT";
class ScrollEvent extends CoolEvent {
    constructor(surface, type, position, delta){
        super(surface, SCROLL_CATEGORY, type);
        this.position = position;
        this.delta = delta;
    }
}
const FOCUS_CATEGORY = "FOCUS_CATEGORY";
const FOCUS_GAINED = "FOCUS_GAINED";
const FOCUS_LOST = "FOCUS_LOST";
class FocusEvent extends CoolEvent {
    constructor(surface, FOCUS_GAINED1){
        super(surface, FOCUS_CATEGORY, FOCUS_GAINED1);
    }
}
const COMMAND_CATEGORY = "COMMAND_CATEGORY";
const COMMAND_ACTION = "action";
class CommandEvent extends CoolEvent {
    constructor(ctx, type, target){
        super(ctx, COMMAND_CATEGORY, type);
        this.target = target;
    }
}
const COMMAND_CHANGE = "change";
const CLIPBOARD_CATEGORY = "CLIPBOARD_CATEGORY";
const CLIPBOARD_COPY = "ClipboardCopy";
const CLIPBOARD_CUT = "ClipboardCut";
const CLIPBOARD_PASTE = "ClipboardPaste";
class ClipboardEvent extends CoolEvent {
}
class BaseParentView {
    constructor(id){
        this.id = id;
        this._size = new Size(100, 100);
        this._position = new Point(0, 0);
        this._children = [];
        this._name = "unnamed";
        this._listeners = new Map();
        this._visible = true;
        this._hflex = false;
        this._vflex = false;
    }
    hflex() {
        return this._hflex;
    }
    set_hflex(hflex) {
        this._hflex = hflex;
    }
    vflex() {
        return this._vflex;
    }
    set_vflex(vflex) {
        this._vflex = vflex;
    }
    log(...args) {
        console.log(this.name(), ...args);
    }
    size() {
        return this._size;
    }
    set_size(size) {
        this._size = size;
    }
    position() {
        return this._position;
    }
    set_position(point) {
        this._position = point;
    }
    clip_children() {
        return false;
    }
    draw(g) {}
    get_children() {
        return this._children;
    }
    find_child(id) {
        // @ts-ignore
        return this.get_children().find((ch)=>ch.id === id);
    }
    add(view) {
        this._children.push(view);
    }
    remove(view) {
        this._children = this._children.filter((ch)=>ch !== view);
    }
    input(event) {}
    is_parent_view() {
        return true;
    }
    name() {
        return this._name;
    }
    set_name(name) {
        this._name = name;
    }
    on(type, cb) {
        this._get_listeners(type).push(cb);
    }
    off(type, cb) {
        this._listeners.set(type, this._get_listeners(type).filter((c)=>c != cb));
    }
    fire(type, payload) {
        this._get_listeners(type).forEach((cb)=>cb(payload));
    }
    visible() {
        return this._visible;
    }
    _get_listeners(type) {
        if (!this._listeners.has(type)) this._listeners.set(type, []);
        return this._listeners.get(type);
    }
    can_receive_mouse() {
        return false;
    }
}
class BaseView {
    constructor(id){
        this.id = id;
        this._size = new Size(100, 100);
        this._position = new Point(0, 0);
        this._visible = true;
        this._name = "unnamed";
        this._listeners = new Map();
        this._hflex = false;
        this._vflex = false;
    }
    hflex() {
        return this._hflex;
    }
    vflex() {
        return this._vflex;
    }
    log(...args) {
        console.log(`${this.name()}:`, ...args);
    }
    _get_listeners(type) {
        if (!this._listeners.has(type)) this._listeners.set(type, []);
        return this._listeners.get(type);
    }
    on(type, cb) {
        this._get_listeners(type).push(cb);
    }
    off(type, cb) {
        this._listeners.set(type, this._get_listeners(type).filter((c)=>c != cb));
    }
    fire(type, payload) {
        this._get_listeners(type).forEach((cb)=>cb(payload));
    }
    size() {
        return this._size;
    }
    set_size(size) {
        this._size = size;
    }
    position() {
        return this._position;
    }
    set_position(point) {
        this._position = point;
    }
    input(event) {}
    name() {
        return this._name;
    }
    set_name(name) {
        this._name = name;
    }
    visible() {
        return this._visible;
    }
}
function with_props(comp, json) {
    if (!json) throw new Error("null json object");
    if (!comp) throw new Error("null component");
    Object.keys(json).forEach((key)=>{
        //already handled type
        if (key === "type") return;
        //handle children separately
        if (key === "children") return;
        //id is a property instead of a setter
        if (key === "id") {
            // @ts-ignore
            comp.id = json.id;
            return;
        }
        let setter = `set_${key}`;
        // console.log("setting",key,setter)
        if (comp[setter]) comp[setter](json[key]);
        else console.log("no setter", setter);
    });
    return comp;
}
function with_action(view, cb) {
    view.on(COMMAND_ACTION, cb);
    return view;
}
function with_change(view, cb) {
    view.on(COMMAND_CHANGE, cb);
    return view;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gkKU3":[function(require,module,exports) {
exports.interopDefault = function(a) {
    return a && a.__esModule ? a : {
        default: a
    };
};
exports.defineInteropFlag = function(a) {
    Object.defineProperty(a, "__esModule", {
        value: true
    });
};
exports.exportAll = function(source, dest) {
    Object.keys(source).forEach(function(key) {
        if (key === "default" || key === "__esModule" || dest.hasOwnProperty(key)) return;
        Object.defineProperty(dest, key, {
            enumerable: true,
            get: function() {
                return source[key];
            }
        });
    });
    return dest;
};
exports.export = function(dest, destName, get) {
    Object.defineProperty(dest, destName, {
        enumerable: true,
        get: get
    });
};

},{}],"1Z0N5":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "log", ()=>log);
parcelHelpers.export(exports, "rect_from_pos_size", ()=>rect_from_pos_size);
parcelHelpers.export(exports, "CanvasSurface", ()=>CanvasSurface);
var _style = require("./style");
var _core = require("./core");
function log(...args) {
    console.log("SNAKE:", ...args);
}
const CLEAR_COLOR = "#f0f0f0";
function rect_from_pos_size(point, size) {
    return new (0, _core.Rect)(point.x, point.y, size.w, size.h);
}
class MouseInputService {
    constructor(surface){
        this.surface = surface;
        this.down = false;
        this.last_point = new (0, _core.Point)(0, 0);
    }
    trigger_mouse_down(position, button) {
        this.down = true;
        this.last_point = position;
        this.path = this.scan_path(position);
        this.target = this.path[this.path.length - 1] // last
        ;
        let evt = new (0, _core.PointerEvent)(this.surface, (0, _core.POINTER_DOWN), position, new (0, _core.Point)(0, 0));
        evt.button = button;
        evt.target = this.target;
        this.propagatePointerEvent(evt, this.path);
        this.surface.repaint();
    }
    trigger_mouse_move(position, button) {
        let delta = position.subtract(this.last_point);
        this.last_point = position.clone();
        let evt;
        if (this.down) evt = new (0, _core.PointerEvent)(this.surface, (0, _core.POINTER_DRAG), position, delta);
        else {
            this.path = this.scan_path(position);
            evt = new (0, _core.PointerEvent)(this.surface, (0, _core.POINTER_MOVE), position, delta);
        }
        evt.button = button;
        evt.target = this.path[this.path.length - 1] // last
        ;
        this.propagatePointerEvent(evt, this.path);
        this.surface.repaint();
    }
    trigger_mouse_up(position, button) {
        this.down = false;
        let evt = new (0, _core.PointerEvent)(this.surface, (0, _core.POINTER_UP), position, new (0, _core.Point)(0, 0));
        evt.button = button;
        evt.target = this.path[this.path.length - 1] // last
        ;
        this.propagatePointerEvent(evt, this.path);
        this.surface.repaint();
    }
    trigger_scroll(position, delta) {
        this.path = this.scan_path(position);
        let evt = new (0, _core.ScrollEvent)(this.surface, (0, _core.SCROLL_EVENT), position, delta);
        this.propagateScrollEvent(evt, this.path);
    }
    calculate_path_to_cursor(view, position, path) {
        // this.log('searching for',position,'on',view.name())
        if (!view) return false;
        if (!view.visible()) return false;
        let bounds = rect_from_pos_size(view.position(), view.size());
        if (bounds.contains(position)) {
            // @ts-ignore
            if (view.is_parent_view && view.is_parent_view()) {
                let parent = view;
                // go in reverse order to the top drawn children are picked first
                for(let i = parent.get_children().length - 1; i >= 0; i--){
                    let ch = parent.get_children()[i];
                    let pos = position.subtract(view.position());
                    let picked = this.calculate_path_to_cursor(ch, pos, path);
                    if (picked) {
                        path.unshift(ch);
                        return true;
                    }
                }
                if (parent.can_receive_mouse()) return true;
            } else return true;
        }
        return false;
    }
    log(...args) {
        console.log("MouseService:", ...args);
    }
    scan_path(position) {
        let path = [];
        this.calculate_path_to_cursor(this.surface.root(), position, path);
        // this.log("final path is",path)
        return path;
    }
    propagatePointerEvent(evt, path) {
        let stopped = false;
        let pt = evt.position;
        path.forEach((view)=>{
            if (stopped) {
                this.log("done");
                return;
            }
            // this.log("down: view",view.name())
            evt.position = evt.position.subtract(view.position());
            view.input(evt);
            if (evt.stopped) stopped = true;
        });
    }
    propagateScrollEvent(evt, path) {
        let stopped = false;
        let pt = evt.position.clone();
        evt.direction = "down";
        path.forEach((view)=>{
            if (stopped) return;
            evt.position = evt.position.subtract(view.position());
            view.input(evt);
            if (evt.stopped) stopped = true;
        });
        if (stopped) return;
        path.reverse();
        evt.direction = "up";
        path.forEach((view)=>{
            if (stopped) // this.log("done")
            return;
            evt.position = evt.position.add(view.position());
            view.input(evt);
            if (evt.stopped) stopped = true;
        });
    }
}
class KeyboardInputService {
    log(...args) {
        console.log("KeyboardService:", ...args);
    }
    constructor(surface){
        this.surface = surface;
    }
    dispatch_keyboard_focus_change(old_focus, new_focus) {
        let e_old = new (0, _core.FocusEvent)(this.surface, (0, _core.FOCUS_LOST));
        //send focus lost to old focus
        if (old_focus) old_focus.input(e_old);
        //send focus gained to new focus
        let e_new = new (0, _core.FocusEvent)(this.surface, (0, _core.FOCUS_GAINED));
        if (new_focus) new_focus.input(e_new);
    //don't use a path, no one can intercept?
    }
    calculate_path_to_keyboard_focus(root, target) {
        if (!root) return false;
        if (!root.visible()) return false;
        if (root === target) return [
            root
        ];
        // @ts-ignore
        if (root.is_parent_view && root.is_parent_view()) {
            let parent = root;
            for(let i = parent.get_children().length - 1; i >= 0; i--){
                let ch = parent.get_children()[i];
                // this.log('checking child',ch)
                let res = this.calculate_path_to_keyboard_focus(ch, target);
                if (res) {
                    res.unshift(root);
                    return res;
                }
            }
        }
    }
    trigger_key_down(key, code, modifiers) {
        let evt = new (0, _core.KeyboardEvent)(this.surface, (0, _core.KEYBOARD_DOWN));
        evt.key = key;
        evt.code = code;
        evt.modifiers = modifiers;
        let path = this.calculate_path_to_keyboard_focus(this.surface.root(), this.surface.keyboard_focus());
        this.surface.propagateKeyboardEvent(evt, path);
        this.surface.repaint();
    }
    trigger_key_up(key, code, modifiers) {
        let evt = new (0, _core.KeyboardEvent)(this.surface, (0, _core.KEYBOARD_UP));
        evt.key = key;
        evt.code = code;
        evt.modifiers = modifiers;
        let path = this.calculate_path_to_keyboard_focus(this.surface.root(), this.surface.keyboard_focus());
        this.surface.propagateKeyboardEvent(evt, path);
        this.surface.repaint();
    }
}
class CanvasSurface {
    size() {
        return new (0, _core.Size)(this.w, this.h);
    }
    global_smoothing = true;
    constructor(w, h, scale){
        this.log("making canvas ", w, h);
        this.w = w;
        this.h = h;
        this.scale = this.scale || 1;
        this.canvas = document.createElement("canvas");
        this.canvas.width = w * window.devicePixelRatio * this.scale;
        this.canvas.height = h * window.devicePixelRatio * this.scale;
        this.log("real canvas is", this.canvas.width, this.canvas.height);
        this.canvas.setAttribute("tabindex", "0");
        //turn this on for high-dpi support
        this.canvas.style.width = `${this.w * this.scale}px`;
        this.canvas.style.height = `${this.h * this.scale}px`;
        this.log("canvas style = ", this.canvas.style);
        this.ctx = this.canvas.getContext("2d");
        this.debug = false;
        this.clear();
        this.fonts = new Map();
        this._pointer_target = null;
    }
    addToPage() {
        document.body.appendChild(this.canvas);
    }
    set_root(root) {
        this._root = root;
    }
    root() {
        return this._root;
    }
    repaint() {
        if (this.debug) console.time("repaint");
        this.layout_stack();
        this.clear();
        this.draw_stack();
        if (this.debug) console.timeEnd("repaint");
    }
    clear() {
        this.ctx.fillStyle = CLEAR_COLOR;
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
    }
    layout_stack() {
        if (!this._root) console.warn("root is null");
        else {
            let available_size = new (0, _core.Size)(this.w, this.h);
            // this.log("layout_stack with size",available_size)
            let size = this._root.layout(this, available_size);
        // console.log("canvas, root requested",size)
        }
    }
    draw_stack() {
        this.ctx.imageSmoothingEnabled = this.global_smoothing;
        this.ctx.save();
        this.ctx.translate(0.5, 0.5);
        this.ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
        this.ctx.scale(this.scale, this.scale);
        this.debug_draw_rect(new (0, _core.Rect)(0, 0, this.w - 1, this.h - 1), "canvas");
        if (this._root) this.draw_view(this._root);
        this.ctx.restore();
    }
    draw_view(view) {
        this.ctx.save();
        let pos = view.position();
        this.ctx.translate(pos.x, pos.y);
        // @ts-ignore
        // console.log("drawing",view.id,view.name())
        if (view.visible()) view.draw(this);
        // @ts-ignore
        if (view.is_parent_view && view.is_parent_view() && view.visible()) {
            let parent = view;
            if (parent.clip_children()) {
                this.ctx.beginPath();
                let size = view.size();
                this.ctx.rect(0, 0, size.w, size.h);
                this.ctx.clip();
            }
            parent.get_children().forEach((ch)=>{
                if (this.debug) this.ctx.save();
                this.draw_view(ch);
                if (this.debug) this.ctx.restore();
            });
        }
        let bds = rect_from_pos_size(view.position(), view.size());
        // @ts-ignore
        this.debug_draw_rect(bds, view.name());
        this.ctx.restore();
    }
    fill(rect, color) {
        this.ctx.fillStyle = color;
        this.ctx.fillRect(rect.x, rect.y, rect.w, rect.h);
    }
    stroke(rect, color) {
        this.ctx.lineWidth = 1 * this.scale;
        this.ctx.strokeStyle = color;
        this.ctx.strokeRect(rect.x, rect.y, rect.w, rect.h);
    }
    fillBackgroundSize(size, color) {
        this.ctx.fillStyle = color;
        this.ctx.fillRect(0, 0, size.w, size.h);
    }
    strokeBackgroundSize(size, color) {
        this.ctx.strokeStyle = color;
        this.ctx.strokeRect(0, 0, size.w, size.h);
    }
    debug_draw_rect(bds, title) {
        if (!this.debug) return;
        this.ctx.strokeStyle = "black";
        this.ctx.lineWidth = 0.5;
        let cx = bds.x + bds.w / 2;
        let cy = bds.y + bds.h / 2;
        for(let i = 0; i < 3; i++){
            this.ctx.beginPath();
            this.ctx.strokeStyle = i % 2 === 1 ? "red" : "black";
            this.ctx.rect(bds.x + i, bds.y + i, bds.w - i * 2, bds.h - i * 2);
            this.ctx.stroke();
        }
        let str = `${title} (${bds.x.toFixed(1)},${bds.y.toFixed(1)}) (${bds.w.toFixed(1)}x${bds.h.toFixed(1)})`;
        for(let i1 = 0; i1 < 3; i1++){
            this.ctx.font = "10px sans-serif";
            this.ctx.fillStyle = "white";
            this.ctx.fillText(str, cx + 3 + i1, cy + 3 + i1);
        }
        for(let i2 = 0; i2 < 1; i2++){
            this.ctx.font = "10px sans-serif";
            this.ctx.fillStyle = "black";
            this.ctx.fillText(str, cx + 3 + i2 + 1, cy + 3 + i2 + 1);
        }
    }
    fillRect(x, y, w, h, color) {
        this.ctx.fillStyle = color;
        this.ctx.fillRect(x, y, w, h);
    }
    screen_to_local(evt) {
        let rect = this.canvas.getBoundingClientRect();
        let pt = new (0, _core.Point)(evt.x - rect.x, evt.y - rect.y);
        pt.x /= this.scale;
        pt.y /= this.scale;
        return pt;
    }
    propagateKeyboardEvent(evt, path) {
        if (this._input_callback) this._input_callback(evt);
        if (!this._keyboard_focus) // if(this._input_callback) this._input_callback(evt)
        return;
        if (!path) {
            this.log("no path, can't propagate");
            return;
        }
        let stopped = false;
        path.forEach((view)=>{
            if (stopped) {
                this.log("bailing out early");
                return;
            }
            view.input(evt);
            if (evt.stopped) stopped = true;
        });
    // if(this._keyboard_focus) this._keyboard_focus.input(evt)
    // if(this._input_callback) this._input_callback(evt)
    }
    keyboard_focus() {
        return this._keyboard_focus;
    }
    set_keyboard_focus(view) {
        let old = this._keyboard_focus;
        this._keyboard_focus = view;
        this.keyboard.dispatch_keyboard_focus_change(old, this._keyboard_focus);
    }
    is_keyboard_focus(view) {
        return view === this._keyboard_focus;
    }
    release_keyboard_focus(view) {
        this._keyboard_focus = null;
    }
    on_input(cb) {
        this._input_callback = cb;
    }
    measureText(caption, font_name) {
        if (font_name && this.fonts.has(font_name)) {
            let font = this.fonts.get(font_name);
            if (font) return font.measureText(caption);
        }
        this.ctx.font = (0, _style.StandardTextStyle);
        let metrics = this.ctx.measureText(caption);
        if ("fontBoundingBoxAscent" in metrics) return new (0, _core.Size)(metrics.width, metrics.fontBoundingBoxAscent + metrics.fontBoundingBoxDescent);
        return new (0, _core.Size)(metrics.width, 16);
    }
    fillStandardText(caption, x, y, font_name, scale) {
        if (!scale) scale = 1;
        if (font_name && this.fonts.has(font_name)) {
            let font = this.fonts.get(font_name);
            if (font) {
                font.fillText(this.ctx, caption, x, y - (0, _style.StandardTextHeight), scale);
                return;
            }
        }
        this.ctx.fillStyle = (0, _style.StandardTextColor);
        this.ctx.font = (0, _style.StandardTextStyle);
        this.ctx.fillText(caption, x, y);
    }
    draw_glyph(codepoint, x, y, font_name, fill, scale) {
        if (!scale) scale = 1;
        this.ctx.fillStyle = fill;
        if (font_name && this.fonts.has(font_name)) {
            let font = this.fonts.get(font_name);
            if (font) font.draw_glpyh(this.ctx, codepoint, x, y, scale);
        }
    }
    log(...args) {
        console.log("CANVAS: ", ...args);
    }
    load_jsonfont(basefont_data, name, ref_name) {
        let fnt = basefont_data.fonts.find((ft)=>ft.name === name);
        this.fonts.set(ref_name, new CanvasFont(fnt));
    }
    draw_sprite(x, y, sprite, scale) {
        this.ctx.drawImage(sprite._img, x, y, sprite._img.width * scale, sprite._img.height * scale);
    }
    draw_tilemap(tilemap, sheet, x, y, scale) {
        tilemap.forEachPixel((val, i, j)=>{
            if (!val || val === 0) return;
            // let sheet = this.doc.get_selected_sheet()
            let tile = sheet.sprites.find((t)=>t.id === val);
            this.ctx.imageSmoothingEnabled = false;
            if (tile) this.ctx.drawImage(tile._img, x + i * scale, y + j * scale, scale, scale);
        });
    }
    find_by_name(name) {
        return this.find_by_name_view(this._root, name);
    }
    find_by_name_view(view, name) {
        if (view.name() === name) return view;
        // @ts-ignore
        if (view.is_parent_view && view.is_parent_view()) {
            let parent = view;
            // go in reverse order to the top drawn children are picked first
            for(let i = parent.get_children().length - 1; i >= 0; i--){
                let ch = parent.get_children()[i];
                let res = this.find_by_name_view(ch, name);
                if (res) return res;
            }
        }
        return null;
    }
    local_to_view(pt, view) {
        let trans = this.calculate_transform_to(this._root, view);
        let f = pt.subtract(trans);
        return f;
    }
    calculate_transform_to(root, view) {
        if (root === view) return root.position().clone();
        // @ts-ignore
        if (root.is_parent_view && root.is_parent_view()) {
            let parent = root;
            for(let i = 0; i < parent.get_children().length; i++){
                let ch = parent.get_children()[i];
                let ptx = this.calculate_transform_to(ch, view);
                if (ptx) return ptx.add(root.position());
            }
        }
        return null;
    }
    view_to_local(pt, view) {
        let trans = this.calculate_transform_to(this._root, view);
        return pt.add(trans);
    }
    _setup_mouse_input() {
        this.mouse = new MouseInputService(this);
        this.canvas.addEventListener("contextmenu", (e)=>{
            e.preventDefault();
            return false;
        });
        this.canvas.addEventListener("mousedown", (domEvent)=>{
            let position = this.screen_to_local(domEvent);
            this.mouse.trigger_mouse_down(position, domEvent.button);
            if (this._input_callback) this._input_callback({});
            domEvent.preventDefault();
        });
        this.canvas.addEventListener("mousemove", (domEvent)=>{
            let position = this.screen_to_local(domEvent);
            this.mouse.trigger_mouse_move(position, domEvent.button);
            if (this._input_callback) this._input_callback({});
            domEvent.preventDefault();
        });
        this.canvas.addEventListener("mouseup", (domEvent)=>{
            let position = this.screen_to_local(domEvent);
            this.mouse.trigger_mouse_up(position, domEvent.button);
            if (this._input_callback) this._input_callback({});
            domEvent.preventDefault();
        });
        this.canvas.addEventListener("wheel", (domEvent)=>{
            let position = this.screen_to_local(domEvent);
            let delta = new (0, _core.Point)(domEvent.deltaX, domEvent.deltaY);
            this.mouse.trigger_scroll(position, delta);
            if (this._input_callback) this._input_callback({});
            domEvent.preventDefault();
        });
    }
    _setup_keyboard_input() {
        this.keyboard = new KeyboardInputService(this);
        document.addEventListener("keydown", (e)=>{
            let modifiers = {
                alt: e.altKey,
                ctrl: e.ctrlKey,
                meta: e.metaKey,
                shift: e.shiftKey
            };
            this.keyboard.trigger_key_down(e.key, e.code, modifiers);
            if (!e.altKey && !e.metaKey) e.preventDefault();
        });
        document.addEventListener("keyup", (e)=>{
            let modifiers = {
                alt: e.altKey,
                ctrl: e.ctrlKey,
                meta: e.metaKey,
                shift: e.shiftKey
            };
            this.keyboard.trigger_key_up(e.key, e.code, modifiers);
            if (!e.altKey && !e.metaKey) e.preventDefault();
        });
    }
    start() {
        this.addToPage();
        this._setup_mouse_input();
        this._setup_keyboard_input();
        this.repaint();
    }
}
class CanvasFont {
    scale = 2;
    constructor(data){
        this.data = data;
        this.metas = new Map();
        this.data.glyphs.forEach((gl)=>{
            this.generate_image(gl);
            this.metas.set(gl.meta.codepoint, gl);
        });
    }
    measureText(text) {
        let xoff = 0;
        let h = 0;
        for(let i = 0; i < text.length; i++){
            let cp = text.codePointAt(i);
            if (this.metas.has(cp)) {
                let glyph = this.metas.get(cp);
                let sw = glyph.w - glyph.meta.left - glyph.meta.right;
                xoff += sw + 1;
                h = Math.max(h, glyph.h);
            } else {
                xoff += 10;
                h = Math.max(h, 10);
            }
        }
        return new (0, _core.Size)(xoff * this.scale, h * this.scale);
    }
    fillText(ctx, text, x, y, scale) {
        if (!scale) scale = 1;
        ctx.fillStyle = "red";
        let size = this.measureText(text);
        let xoff = 0;
        let yoff = 2;
        // ctx.fillRect(x+xoff, y+yoff, size.w, size.h)
        for(let i = 0; i < text.length; i++){
            let cp = text.codePointAt(i);
            let dx = x + xoff * this.scale * scale;
            if (this.metas.has(cp)) {
                let glyph = this.metas.get(cp);
                ctx.imageSmoothingEnabled = false;
                //@ts-ignore
                let img = glyph.img;
                let sx = glyph.meta.left;
                let sy = 0;
                let sw = glyph.w - glyph.meta.left - glyph.meta.right;
                let sh = glyph.h //- glyph.meta.baseline
                ;
                let dy = y + (yoff + glyph.meta.baseline - 1) * this.scale * scale;
                let dw = sw * this.scale * scale;
                let dh = sh * this.scale * scale;
                ctx.drawImage(img, sx, sy, sw, sh, dx, dy, dw, dh);
                xoff += sw + 1;
            } else {
                //missing the glyph
                let ew = 8;
                let dy = y + yoff * this.scale * scale;
                ctx.strokeRect(dx, dy, ew * this.scale * scale, ew * this.scale * scale);
                xoff += ew + 1;
            }
        }
    }
    draw_glpyh(ctx, cp, x, y, scale) {
        let xoff = 0;
        let yoff = 2;
        if (this.metas.has(cp)) {
            let glyph = this.metas.get(cp);
            ctx.imageSmoothingEnabled = false;
            //@ts-ignore
            let img = glyph.img;
            let sx = glyph.meta.left;
            let sy = 0;
            let sw = glyph.w - glyph.meta.left - glyph.meta.right;
            let sh = glyph.h //- glyph.meta.baseline
            ;
            let dx = x + xoff * this.scale * scale;
            let dy = y + (yoff + glyph.meta.baseline - 1) * this.scale * scale;
            let dw = sw * this.scale * scale;
            let dh = sh * this.scale * scale;
            ctx.drawImage(img, sx, sy, sw, sh, dx, dy, dw, dh);
        }
    }
    generate_image(gl) {
        gl.img = document.createElement("canvas");
        gl.img.width = gl.w;
        gl.img.height = gl.h;
        let c = gl.img.getContext("2d");
        c.fillStyle = "green";
        c.fillRect(0, 0, gl.img.width, gl.img.height);
        for(let j = 0; j < gl.h; j++)for(let i = 0; i < gl.w; i++){
            let n = j * gl.w + i;
            let v = gl.data[n];
            if (v % 2 === 0) {
                c.fillStyle = "white";
                // c.fillRect(i, j, 1, 1)
                c.clearRect(i, j, 1, 1);
            }
            if (v % 2 === 1) {
                c.fillStyle = "black";
                c.fillRect(i, j, 1, 1);
            }
        }
    }
}

},{"./style":"llAwq","./core":"6Wpln","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"llAwq":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ButtonBackgroundColor_active", ()=>ButtonBackgroundColor_active);
parcelHelpers.export(exports, "ButtonBackgroundColor_selected", ()=>ButtonBackgroundColor_selected);
parcelHelpers.export(exports, "ButtonBackgroundColor", ()=>ButtonBackgroundColor);
parcelHelpers.export(exports, "ButtonBorderColor", ()=>ButtonBorderColor);
parcelHelpers.export(exports, "StandardSelectionColor", ()=>StandardSelectionColor);
parcelHelpers.export(exports, "StandardTextColor", ()=>StandardTextColor);
parcelHelpers.export(exports, "StandardTextStyle", ()=>StandardTextStyle);
parcelHelpers.export(exports, "StandardTextHeight", ()=>StandardTextHeight);
parcelHelpers.export(exports, "StandardVerticalMargin", ()=>StandardVerticalMargin);
parcelHelpers.export(exports, "StandardLeftPadding", ()=>StandardLeftPadding);
parcelHelpers.export(exports, "StandardPanelBackgroundColor", ()=>StandardPanelBackgroundColor);
const ButtonBackgroundColor_active = "#a3e3ff";
const ButtonBackgroundColor_selected = "#36baec";
const ButtonBackgroundColor = "#e3e3e0";
const ButtonBorderColor = "#949492";
const StandardSelectionColor = ButtonBackgroundColor_active;
const StandardTextColor = "#444";
const StandardTextStyle = "16px sans-serif";
const StandardTextHeight = 20;
const StandardVerticalMargin = 10;
const StandardLeftPadding = 5;
const StandardPanelBackgroundColor = "#f0f0f0";

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5ouc0":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Sprite", ()=>Sprite);
parcelHelpers.export(exports, "Sheet", ()=>Sheet);
parcelHelpers.export(exports, "Tilemap", ()=>Tilemap);
parcelHelpers.export(exports, "SpriteGlyph", ()=>SpriteGlyph);
parcelHelpers.export(exports, "SpriteFont", ()=>SpriteFont);
var _core = require("./core");
class Sprite {
    constructor(id, name, w, h, palette){
        this.id = id || (0, _core.gen_id)("unknown");
        this.name = name || "unknown";
        this.w = w;
        this.h = h;
        this.data = [];
        for(let i = 0; i < this.w * this.h; i++)this.data[i] = 0;
        this._img = document.createElement("canvas");
        this._img.width = this.w;
        this._img.height = this.h;
        this.palette = palette;
    }
    forEachPixel(cb) {
        for(let j = 0; j < this.h; j++)for(let i = 0; i < this.w; i++){
            let n = j * this.w + i;
            let v = this.data[n];
            cb(v, i, j);
        }
    }
    set_pixel(x, y, color) {
        let n = y * this.w + x;
        this.data[n] = color;
        this.sync();
    }
    sync() {
        // console.log("syncing a sprite")
        let c = this._img.getContext("2d");
        let pal = this.palette.get_color_palette();
        c.clearRect(0, 0, this._img.width, this._img.height);
        this.forEachPixel((v, i, j)=>{
            c.fillStyle = pal[v];
            c.fillRect(i, j, 1, 1);
        });
    }
    get_pixel(x, y) {
        let n = y * this.w + x;
        return this.data[n];
    }
    toJsonObj() {
        return {
            clazz: "Sprite",
            id: this.id,
            name: this.name,
            w: this.w,
            h: this.h,
            data: this.data
        };
    }
}
class Sheet {
    constructor(id, name){
        this.id = id || (0, _core.gen_id)("unknown");
        this.name = name || "unknown";
        this.sprites = [];
    }
    add(sprite) {
        this.sprites.push(sprite);
    }
    toJsonObj() {
        return {
            clazz: "Sheet",
            id: this.id,
            name: this.name,
            sprites: this.sprites.map((sp)=>sp.toJsonObj())
        };
    }
}
class Tilemap {
    constructor(id, name, w, h){
        this.id = id || (0, _core.gen_id)("unknown");
        this.name = name || "unknown";
        this.w = w;
        this.h = h;
        this.data = [];
        for(let i = 0; i < this.w * this.h; i++)this.data[i] = 0;
    }
    forEachPixel(cb) {
        for(let j = 0; j < this.h; j++)for(let i = 0; i < this.w; i++){
            let n = j * this.w + i;
            let v = this.data[n];
            cb(v, i, j);
        }
    }
    expand_width(number) {
        let new_tm = new Tilemap("temp", "temp", this.w + number, this.h);
        this.forEachPixel((val, i, j)=>{
            new_tm.set_pixel(i, j, val);
        });
        this.data = new_tm.data;
        this.w = new_tm.w;
        this.h = new_tm.h;
    }
    set_pixel(x, y, color) {
        let n = y * this.w + x;
        this.data[n] = color;
    }
    get_pixel(x, y) {
        let n = y * this.w + x;
        return this.data[n];
    }
    toJsonObj() {
        return {
            clazz: "Tilemap",
            id: this.id,
            name: this.name,
            w: this.w,
            h: this.h,
            data: this.data
        };
    }
}
class SpriteGlyph extends Sprite {
    constructor(id, name, w, h, palette){
        super(id, name, w, h, palette);
        this.meta = {
            codepoint: 300,
            left: 0,
            right: 0,
            baseline: 0
        };
    }
    sync() {
        // console.log("syncing SpriteGlyph")
        let c = this._img.getContext("2d");
        this.forEachPixel((v, i, j)=>{
            if (v % 2 === 0) {
                c.fillStyle = "white";
                c.fillRect(i, j, 1, 1);
            }
            if (v % 2 === 1) {
                c.fillStyle = "black";
                c.fillRect(i, j, 1, 1);
            }
        });
    }
    toJsonObj() {
        let obj = super.toJsonObj();
        // @ts-ignore
        obj.clazz = "Glyph";
        // @ts-ignore
        obj.meta = this.meta;
        // @ts-ignore
        // console.log("saving out",obj.meta)
        return obj;
    }
}
class SpriteFont {
    // private _selected_glyph_index: number;
    constructor(id, name){
        this.id = id || (0, _core.gen_id)("unknown");
        this.name = name || "unknown";
        this.glyphs = [];
    // this._selected_glyph_index = 0
    }
    toJsonObj() {
        return {
            clazz: "Font",
            id: this.id,
            name: this.name,
            glyphs: this.glyphs.map((sp)=>sp.toJsonObj())
        };
    }
    add(spriteGlyph) {
        this.glyphs.push(spriteGlyph);
    }
}

},{"./core":"6Wpln","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"563zL":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Label", ()=>Label);
parcelHelpers.export(exports, "CustomLabel", ()=>CustomLabel);
parcelHelpers.export(exports, "ActionButton", ()=>ActionButton);
parcelHelpers.export(exports, "BaseSelectButton", ()=>BaseSelectButton);
parcelHelpers.export(exports, "ToggleButton", ()=>ToggleButton);
parcelHelpers.export(exports, "CheckButton", ()=>CheckButton);
parcelHelpers.export(exports, "RadioButton", ()=>RadioButton);
parcelHelpers.export(exports, "IconButton", ()=>IconButton);
parcelHelpers.export(exports, "SelectList", ()=>SelectList);
parcelHelpers.export(exports, "Header", ()=>Header);
parcelHelpers.export(exports, "HSpacer", ()=>HSpacer);
parcelHelpers.export(exports, "FontIcon", ()=>FontIcon);
parcelHelpers.export(exports, "DropdownButton", ()=>DropdownButton);
parcelHelpers.export(exports, "TextLine", ()=>TextLine);
parcelHelpers.export(exports, "NumberTextLine", ()=>NumberTextLine);
var _style = require("./style");
var _core = require("./core");
var _containers = require("./containers");
class Label extends (0, _core.BaseView) {
    constructor(caption){
        super((0, _core.gen_id)("label"));
        this._name = "label";
        this._caption = caption || "no caption";
    }
    caption() {
        return this._caption;
    }
    set_caption(caption) {
        this._caption = caption;
    }
    draw(g) {
        g.fillStandardText(this._caption, (0, _style.StandardLeftPadding), (0, _style.StandardTextHeight), "base");
    }
    layout(g, available) {
        this.set_size(g.measureText(this._caption, "base").grow((0, _style.StandardLeftPadding)));
        return this.size();
    }
}
class CustomLabel extends Label {
    constructor(text, cb){
        super(text);
        this.cb = cb;
    }
    draw(ctx) {
        this._caption = this.cb({});
        super.draw(ctx);
    }
}
class ActionButton extends (0, _core.BaseView) {
    constructor(props){
        super((0, _core.gen_id)("button2"));
        this._name = "button2";
        this.caption = "no caption";
        if (props && props.caption) this.caption = props.caption;
        this.active = false;
    }
    set_caption(caption) {
        this.caption = caption;
    }
    draw(g) {
        if (this.active) g.fillBackgroundSize(this.size(), (0, _style.ButtonBackgroundColor_active));
        else g.fillBackgroundSize(this.size(), (0, _style.ButtonBackgroundColor));
        g.strokeBackgroundSize(this.size(), (0, _style.ButtonBorderColor));
        g.fillStandardText(this.caption, (0, _style.StandardLeftPadding), (0, _style.StandardTextHeight), "base");
    }
    input(event) {
        if (event.category !== (0, _core.POINTER_CATEGORY)) return;
        if (event.type === (0, _core.POINTER_DOWN)) this.active = true;
        if (event.type === (0, _core.POINTER_UP)) {
            this.active = false;
            let ae = new (0, _core.CommandEvent)(event.ctx, (0, _core.COMMAND_ACTION), this);
            this.fire(ae.type, ae);
        }
    }
    layout(g, available) {
        this.set_size(g.measureText(this.caption, "base").grow((0, _style.StandardLeftPadding)));
        return this.size();
    }
}
class BaseSelectButton extends (0, _core.BaseView) {
    constructor(){
        super((0, _core.gen_id)("base-button"));
        this._caption = "no caption";
        this._selected = false;
        this.icon = -1;
        this.selected_icon = -1;
        this._active = false;
    }
    selected() {
        return this._selected;
    }
    set_selected(sel) {
        this._selected = sel;
    }
    caption() {
        return this._caption;
    }
    set_caption(caption) {
        this._caption = caption;
    }
    draw(g) {
        let x = (0, _style.StandardLeftPadding);
        let y = (0, _style.StandardLeftPadding);
        if (this.has_icon()) {
            g.draw_glyph(this._selected ? this.selected_icon : this.icon, x, y, "base", "black");
            x += 16 // glyph width
            ;
            x += (0, _style.StandardLeftPadding // space between text and glyph
            );
        }
        g.fillStandardText(this._caption, x, y + (0, _style.StandardTextHeight) - 2, "base");
    }
    input(event) {
        if (event.type === (0, _core.POINTER_DOWN)) this._active = true;
        if (event.type === (0, _core.POINTER_UP)) {
            this._active = false;
            this._selected = !this._selected;
            let ae = new (0, _core.CommandEvent)(event.ctx, (0, _core.COMMAND_CHANGE), this);
            this.fire(ae.type, ae);
        }
    }
    layout(g, available) {
        let size = g.measureText(this._caption, "base").grow((0, _style.StandardLeftPadding));
        if (this.has_icon()) size.w += 16;
        size.w += (0, _style.StandardLeftPadding // gap between icon and texst
        );
        this.set_size(size);
        return size;
    }
    has_icon() {
        return this.icon !== -1;
    }
}
class ToggleButton extends BaseSelectButton {
    // private active: boolean
    constructor(caption){
        super();
        if (caption) this.set_caption(caption);
    }
    draw(ctx) {
        let bg = (0, _style.ButtonBackgroundColor);
        if (this.selected()) bg = (0, _style.ButtonBackgroundColor_selected);
        if (this._active) bg = (0, _style.ButtonBackgroundColor_active);
        ctx.fillBackgroundSize(this.size(), bg);
        ctx.strokeBackgroundSize(this.size(), (0, _style.ButtonBorderColor));
        super.draw(ctx);
    }
}
class CheckButton extends BaseSelectButton {
    constructor(){
        super();
        this.icon = 800;
        this.selected_icon = 801;
    }
}
class RadioButton extends BaseSelectButton {
    constructor(){
        super();
        this.icon = 802;
        this.selected_icon = 803;
    }
}
class IconButton extends (0, _core.BaseView) {
    constructor(){
        super((0, _core.gen_id)("glyph-button"));
        this._name = "glyph-button";
        this.active = false;
        this._icon = 0;
    }
    draw(g) {
        if (this.active) g.fillBackgroundSize(this.size(), (0, _style.ButtonBackgroundColor_active));
        else g.fillBackgroundSize(this.size(), (0, _style.ButtonBackgroundColor));
        g.strokeBackgroundSize(this.size(), (0, _style.ButtonBorderColor));
        if (this._icon !== 0) {
            let x = (0, _style.StandardLeftPadding);
            let y = (0, _style.StandardLeftPadding);
            g.draw_glyph(this._icon, x, y, "base", "black");
        }
    }
    input(event) {
        if (event.category !== (0, _core.POINTER_CATEGORY)) return;
        if (event.type === (0, _core.POINTER_DOWN)) this.active = true;
        if (event.type === (0, _core.POINTER_UP)) {
            this.active = false;
            let ae = new (0, _core.CommandEvent)(event.ctx, (0, _core.COMMAND_ACTION), this);
            this.fire(ae.type, ae);
        }
    }
    layout(g, available) {
        this.set_size(new (0, _core.Size)(16, 16).grow((0, _style.StandardLeftPadding)));
        return this.size();
    }
    icon() {
        return this._icon;
    }
    set_icon(icon) {
        this._icon = icon;
    }
}
class SelectList extends (0, _core.BaseView) {
    constructor(data, renderer){
        super("tree");
        this.data = data;
        this.renderer = renderer;
        this.selected_index = -1;
        this._vflex = true;
    }
    draw(g) {
        g.fillBackgroundSize(this.size(), "#ddd");
        this.data.forEach((item, i)=>{
            if (i === this.selected_index) g.fill(new (0, _core.Rect)(0, 30 * i, this.size().w, 25), (0, _style.StandardSelectionColor));
            let str = this.renderer(item);
            g.fillStandardText(str, (0, _style.StandardLeftPadding), i * 30 + 20, "base");
        });
    }
    input(event) {
        if (event.category !== (0, _core.POINTER_CATEGORY)) return;
        if (event.type === (0, _core.POINTER_DOWN)) {
            let evt = event;
            let pt = evt.position;
            let y = Math.floor(pt.y / 30);
            let item = this.data[y];
            this.selected_index = y;
            this.fire("change", {
                item: item,
                y: y
            });
        }
    }
    set_data(data) {
        this.data = data;
    }
    layout(g, available) {
        if (this.hflex()) this.set_size(new (0, _core.Size)(available.w, available.h));
        else this.set_size(new (0, _core.Size)(200, available.h));
        return this.size();
    }
}
class Header extends (0, _core.BaseView) {
    constructor(caption){
        super((0, _core.gen_id)("header"));
        this._name = "header";
        this.fill = "white";
        this._caption = caption || "no caption";
        this._hflex = true;
    }
    caption() {
        return this._caption;
    }
    set_caption(caption) {
        this._caption = caption;
    }
    draw(g) {
        g.fillBackgroundSize(this.size(), this.fill);
        let size = g.measureText(this._caption, "base");
        let x = (this.size().w - size.w) / 2;
        g.fillStandardText(this._caption, x, (0, _style.StandardTextHeight), "base");
    }
    layout(g, available) {
        let text_size = g.measureText(this._caption, "base").grow((0, _style.StandardLeftPadding));
        this.set_size(new (0, _core.Size)(available.w, text_size.h));
        return this.size();
    }
}
class HSpacer extends (0, _core.BaseView) {
    constructor(){
        super("h-spacer");
        this._hflex = true;
        this._name = "h-spacer";
    }
    layout(g, available) {
        this.set_size(new (0, _core.Size)(available.w, 0));
        return this.size();
    }
    draw(g) {}
}
class FontIcon extends (0, _core.BaseView) {
    constructor(codepoint){
        super((0, _core.gen_id)("fonticon"));
        this.codepoint = codepoint;
    }
    draw(g) {
        g.draw_glyph(this.codepoint, 0, 0, "base", "black");
    }
    layout(g, available) {
        this.set_size(new (0, _core.Size)(16, 16));
        return this.size();
    }
}
class DropdownButton extends ActionButton {
    constructor(){
        super();
        this.actions = [];
        this.on("action", (e)=>{
            let popup = new (0, _containers.PopupContainer)();
            let popup_box = new (0, _containers.VBox)();
            popup_box.set_vflex(false);
            this.actions.forEach((act)=>{
                let button = new ActionButton(act.caption);
                button.set_caption(act.caption);
                button.on("action", ()=>{
                    // @ts-ignore
                    act.fun();
                    popup.hide();
                });
                popup_box.add(button);
            });
            popup.add(popup_box);
            let popup_layer = e.ctx.find_by_name("popup-layer");
            popup_layer.add(popup);
            let off = e.ctx.view_to_local(new (0, _core.Point)(0, 0), this);
            popup.open_at(off.add(new (0, _core.Point)(0, this.size().h)));
        });
    }
    set_actions(actions) {
        this.actions = actions;
    }
}
class TextLine extends (0, _core.BaseView) {
    constructor(){
        super((0, _core.gen_id)("text-line"));
        this._name = "@text-line";
        this.text = "abc";
        this.pref_width = 100;
        this.cursor = this.text.length;
    }
    draw(g) {
        let bg = "#ddd";
        if (g.is_keyboard_focus(this)) bg = "white";
        g.fillBackgroundSize(this.size(), bg);
        g.strokeBackgroundSize(this.size(), "black");
        if (g.is_keyboard_focus(this)) {
            // @ts-ignore
            g.ctx.fillStyle = (0, _style.StandardTextColor);
            // @ts-ignore
            g.ctx.font = (0, _style.StandardTextStyle);
            let parts = this._parts();
            let bx = 5;
            let ax = bx + g.measureText(parts.before, "base").w;
            g.fillStandardText(parts.before, bx, 20, "base");
            g.fillStandardText(parts.after, ax, 20, "base");
            // @ts-ignore
            g.ctx.fillStyle = "black";
            // @ts-ignore
            g.ctx.fillRect(ax, 2, 2, 20);
        } else g.fillStandardText(this.text, 5, 20, "base");
    }
    input(event) {
        event.category;
        if (event.type === (0, _core.POINTER_DOWN)) event.ctx.set_keyboard_focus(this);
        if (event.type === (0, _core.KEYBOARD_DOWN)) {
            let e = event;
            if (e.code === "KeyD" && e.modifiers.ctrl) return this.delete_right();
            if (e.code === "Backspace") return this.delete_left();
            if (e.code === "ArrowLeft") return this.cursor_left();
            if (e.code === "ArrowRight") return this.cursor_right();
            if (e.code === "Enter") {
                event.ctx.release_keyboard_focus(this);
                this.fire("action", this.text);
                return;
            }
            if (e.key && e.key.length === 1) this.insert(e.key);
        }
    }
    layout(g, available) {
        this.set_size(new (0, _core.Size)(this.pref_width, 26));
        if (this._hflex) this.size().w = available.w;
        return this.size();
    }
    insert(key) {
        let parts = this._parts();
        this.text = `${parts.before}${key}${parts.after}`;
        this.cursor_right();
        this.fire("change", this.text);
    }
    delete_left() {
        let parts = this._parts();
        this.text = `${parts.before.slice(0, parts.before.length - 1)}${parts.after}`;
        this.cursor_left();
        this.fire("change", this.text);
    }
    delete_right() {
        let parts = this._parts();
        this.text = `${parts.before}${parts.after.slice(1)}`;
        this.fire("change", this.text);
    }
    cursor_left() {
        this.cursor -= 1;
        if (this.cursor < 0) this.cursor = 0;
    }
    cursor_right() {
        this.cursor += 1;
        if (this.cursor > this.text.length) this.cursor = this.text.length;
    }
    _parts() {
        return {
            before: this.text.slice(0, this.cursor),
            after: this.text.slice(this.cursor)
        };
    }
    set_text(name) {
        this.text = name;
        this.cursor = this.text.length;
        this.fire("change", this.text);
    }
    set_pref_width(w) {
        this.pref_width = w;
    }
}
class NumberTextLine extends (0, _containers.HBox) {
    constructor(){
        super();
        this.pad = 1;
        this._value = 0;
        this.text_line = new TextLine();
        this.add(this.text_line);
        this.text_line.on("change", ()=>{
            let v = parseInt(this.text_line.text, 10);
            if (Number.isInteger(v)) this._value = v;
            else this.log("invalid!");
        });
        this.up_button = new IconButton();
        this.up_button.set_icon(8593);
        this.up_button.on("action", ()=>{
            this.set_value(this.value() + 1);
        });
        this.down_button = new IconButton();
        this.down_button.set_icon(8595);
        this.down_button.on("action", ()=>{
            this.set_value(this.value() - 1);
        });
        this.add(this.up_button);
        this.add(this.down_button);
    }
    draw(g) {
        super.draw(g);
        if (!this.is_valid()) g.strokeBackgroundSize(this.size(), "red");
    }
    set_value(value) {
        this._value = value;
        this.text_line.set_text("" + value);
    }
    is_valid() {
        let v = parseInt(this.text_line.text);
        return Number.isInteger(v);
    }
    value() {
        return this._value;
    }
}

},{"./style":"llAwq","./core":"6Wpln","./containers":"kfq5H","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kfq5H":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "LayerView", ()=>LayerView);
parcelHelpers.export(exports, "HBox", ()=>HBox);
parcelHelpers.export(exports, "VBox", ()=>VBox);
parcelHelpers.export(exports, "GrowPanel", ()=>GrowPanel);
parcelHelpers.export(exports, "ScrollView", ()=>ScrollView);
parcelHelpers.export(exports, "PopupContainer", ()=>PopupContainer);
parcelHelpers.export(exports, "PopupLayer", ()=>PopupLayer);
parcelHelpers.export(exports, "DialogLayer", ()=>DialogLayer);
parcelHelpers.export(exports, "DialogContainer", ()=>DialogContainer);
parcelHelpers.export(exports, "KeystrokeCaptureView", ()=>KeystrokeCaptureView);
var _core = require("./core");
class LayerView extends (0, _core.BaseParentView) {
    constructor(name){
        super((0, _core.gen_id)("layer"));
        this._type = "layer-view";
        if (name) this._name = name;
    }
    draw(g) {}
    layout(g, available) {
        this._children.forEach((ch)=>ch.layout(g, available));
        this.set_size(available);
        return available;
    }
    set_visible(visible) {
        this._visible = visible;
    }
}
class HBox extends (0, _core.BaseParentView) {
    constructor(){
        super((0, _core.gen_id)("hbox"));
        this._valign = "top";
        this.pad = 0;
        this._fill = null;
    }
    set_fill(fill) {
        this._fill = fill;
    }
    set_valign(valign) {
        this._valign = valign;
    }
    layout(g, real_available) {
        let available = real_available.shrink(this.pad);
        //split out flex and non-flex children
        let yes_flex = this._children.filter((ch)=>ch.hflex());
        let non_flex = this._children.filter((ch)=>!ch.hflex());
        //call layout on the non-flex children first
        let total_w = 0;
        let leftover_w = available.w;
        non_flex.map((ch)=>{
            let size = ch.layout(g, new (0, _core.Size)(leftover_w, available.h));
            total_w += size.w;
            leftover_w -= size.w;
        });
        if (yes_flex.length > 0) {
            //allocate the rest of the space equally to the flex children
            let flex_avail = new (0, _core.Size)((available.w - total_w) / yes_flex.length, available.h);
            //call layout on the flex children
            yes_flex.map((ch)=>{
                let size = ch.layout(g, flex_avail);
                total_w += size.w;
            });
        }
        let maxh = 0;
        //find the max height
        this.get_children().forEach((ch)=>maxh = Math.max(ch.size().h, maxh));
        let nx = this.pad;
        let ny = this.pad;
        //place all children (they've already set their width and height)
        this._children.forEach((ch)=>{
            if (this._valign === "top") ch.set_position(new (0, _core.Point)(nx, ny));
            if (this._valign === "center") ch.set_position(new (0, _core.Point)(nx, (maxh - ch.size().h) / 2));
            if (this._valign === "bottom") ch.set_position(new (0, _core.Point)(nx, maxh - ch.size().h));
            if (this._valign === "stretch") {
                ch.set_position(new (0, _core.Point)(nx, ny));
                ch.size().h = maxh;
            }
            nx += ch.size().w;
        });
        //return own size
        this.set_size(new (0, _core.Size)(nx + this.pad * 2, maxh + this.pad * 2));
        if (this.vflex()) this.size().h = real_available.h;
        if (this.hflex()) this.size().w = real_available.w;
        return this.size();
    }
    draw(g) {
        if (this._fill) g.fillBackgroundSize(this.size(), this._fill);
    }
}
class VBox extends (0, _core.BaseParentView) {
    constructor(){
        super((0, _core.gen_id)("vbox"));
        this._fill = null;
        this.halign = "left";
        this.pad = 0;
    }
    fill() {
        return this._fill;
    }
    set_fill(fill) {
        this._fill = fill;
    }
    layout(g, real_available) {
        let available = real_available.shrink(this.pad);
        let yes_flex = this.get_children().filter((ch)=>ch.vflex());
        let non_flex = this.get_children().filter((ch)=>!ch.vflex());
        //call layout on the non-flex children first
        let total_h = 0;
        let leftover_h = available.h;
        non_flex.map((ch)=>{
            let size = ch.layout(g, new (0, _core.Size)(available.w, leftover_h));
            total_h += size.h;
            leftover_h -= size.h;
        });
        if (yes_flex.length > 0) {
            //allocate the rest of the space equally to the flex children
            let flex_avail = new (0, _core.Size)(available.w, (available.h - total_h) / yes_flex.length);
            //call layout on the flex children
            yes_flex.map((ch)=>{
                let size = ch.layout(g, flex_avail);
                total_h += size.h;
            });
        }
        //place all children (they've already set their width and height)
        let nx = this.pad;
        let ny = this.pad;
        let maxw = 0;
        this.get_children().forEach((ch)=>maxw = Math.max(ch.size().w, maxw));
        this.get_children().forEach((ch)=>{
            if (this.halign === "left") ch.set_position(new (0, _core.Point)(nx, ny));
            if (this.halign === "center") ch.set_position(new (0, _core.Point)((maxw - ch.size().w) / 2, ny));
            if (this.halign === "right") ch.set_position(new (0, _core.Point)(maxw - ch.size().w, ny));
            if (this.halign === "stretch") {
                ch.set_position(new (0, _core.Point)(nx, ny));
                ch.size().w = maxw;
            }
            ny += ch.size().h;
        });
        //return own size
        this.size().w = maxw + this.pad * 2;
        this.size().h = ny + this.pad * 2;
        if (this.hflex()) this.size().w = available.w;
        if (this.vflex()) this.size().h = available.h;
        return this.size();
    }
    draw(g) {
        if (this._fill) g.fillBackgroundSize(this.size(), this._fill);
    }
    clear_children() {
        this._children = [];
    }
}
class GrowPanel extends (0, _core.BaseParentView) {
    constructor(){
        super((0, _core.gen_id)("grow"));
        this.fill = null;
        this._hflex = true;
        this._vflex = true;
    }
    layout(g, available) {
        this.set_size(available);
        return this.size();
    }
    draw(g) {
        if (this.fill) g.fillBackgroundSize(this.size(), this.fill);
    }
    set_fill(fill) {
        this.fill = fill;
    }
    with_fill(fill) {
        this.fill = fill;
        return this;
    }
}
class ScrollWrapper extends (0, _core.BaseParentView) {
    constructor(){
        super("scroll-wrapper");
        this.xoff = 0;
        this.yoff = 0;
        this._name = "scroll-wrapper";
    }
    clip_children() {
        return true;
    }
    layout(g, available) {
        if (this.yoff > 0) this.yoff = 0;
        if (this.xoff > 0) this.xoff = 0;
        this.set_size(available);
        this.get_children().forEach((ch)=>{
            let size = ch.layout(g, available);
            if (size.w + this.xoff < available.w) this.xoff = available.w - size.w;
            if (size.h + this.yoff < available.h) this.yoff = available.h - size.h;
            if (size.w < available.w) this.xoff = (available.w - size.w) / 2;
            if (size.h < available.h) this.yoff = (available.h - size.h) / 2;
            ch.set_position(new (0, _core.Point)(this.xoff, this.yoff));
        });
        return available;
    }
    input(event) {
        if (event.type === (0, _core.SCROLL_EVENT) && event.direction === "up") {
            let e = event;
            this.xoff -= e.delta.x;
            this.yoff -= e.delta.y;
            e.stopped = true;
            e.ctx.repaint();
        }
    }
}
class ScrollBar extends (0, _core.BaseView) {
    constructor(vert, wrapper){
        super((0, _core.gen_id)("scroll-bar"));
        this.wrapper = wrapper;
        this.vert = vert;
        if (this.vert) this.set_size(new (0, _core.Size)(20, 100));
        else this.set_size(new (0, _core.Size)(100, 20));
    }
    draw(g) {
        //draw the gutter
        g.fillBackgroundSize(this.size(), "#888");
        //draw the thumb
        if (this.wrapper.get_children().length == 1) {
            let viewport_size = this.wrapper.size();
            let content_size = this.wrapper.get_children()[0].size();
            // this.log("content",content,'vs',wsize)
            if (this.vert) {
                let gutter_length = this.size().h - 40;
                let fract = viewport_size.h / content_size.h;
                let s = gutter_length * fract;
                let thumb_off = this.wrapper.yoff * fract;
                g.fill(new (0, _core.Rect)(0, 20 - thumb_off, 20, s), "#ccc");
            } else {
                let gutter_length = this.size().w - 50;
                let fract = viewport_size.w / content_size.w;
                let s = gutter_length * fract;
                let thumb_off = this.wrapper.xoff * fract;
                g.fill(new (0, _core.Rect)(20 - thumb_off, 0, s, 20), "#ccc");
            }
        }
        //draw the arrows
        if (this.vert) {
            g.fill(new (0, _core.Rect)(0, 0, 20, 20), "#999");
            g.draw_glyph(8593, 0, 0, "base", "black", 1);
            g.fill(new (0, _core.Rect)(0, this.size().h - 20, 20, 20), "#999");
            g.draw_glyph(8595, 0, this.size().h - 20, "base", "black", 1);
        } else {
            g.fill(new (0, _core.Rect)(0, 0, 20, 20), "#999");
            g.draw_glyph(8592, 0, 0, "base", "black", 1);
            g.fill(new (0, _core.Rect)(this.size().w - 20, 0, 20, 20), "#999");
            g.draw_glyph(8594, this.size().w - 20, 0, "base", "black", 1);
        }
    }
    input(e) {
        if (e.category !== (0, _core.POINTER_CATEGORY)) return;
        let event = e;
        if (event.type === (0, _core.POINTER_DOWN)) {
            if (this.vert) {
                if (event.position.y < 20) this.wrapper.yoff += 20;
                if (event.position.y > this.size().h - 20) this.wrapper.yoff -= 20;
            } else {
                if (event.position.x < 20) this.wrapper.xoff += 20;
                if (event.position.x > this.size().w - 20) this.wrapper.xoff -= 20;
            }
        }
        if (event.type === (0, _core.POINTER_DRAG)) {
            let viewport_size = this.wrapper.size();
            let content_size = this.wrapper.get_children()[0].size();
            if (this.vert) {
                let fract = viewport_size.h / content_size.h;
                this.wrapper.yoff -= event.delta.y / fract;
            } else {
                let fract = viewport_size.w / content_size.w;
                this.wrapper.xoff -= event.delta.x / fract;
            }
            event.ctx.repaint();
        }
        if (event.type === "wheel") {
            let viewport_size = this.wrapper.size();
            let content_size = this.wrapper.get_children()[0].size();
            if (this.vert) {
                let fract = viewport_size.h / content_size.h;
                this.wrapper.yoff -= event.delta.y / fract;
            } else {
                let fract = viewport_size.w / content_size.w;
                this.wrapper.xoff -= event.delta.x / fract;
            }
            event.ctx.repaint();
        }
    }
    layout(g, available) {
        return this.size();
    }
}
class ScrollView extends (0, _core.BaseParentView) {
    constructor(){
        super((0, _core.gen_id)("scroll-view"));
        this._name = "scroll-view";
        this._pref_width = 300;
        this.wrapper = new ScrollWrapper();
        this.add(this.wrapper);
        this.hbar = new ScrollBar(false, this.wrapper);
        // @ts-ignore
        this.hbar._name = "h-scroll-bar";
        this.add(this.hbar);
        this.vbar = new ScrollBar(true, this.wrapper);
        // @ts-ignore
        this.vbar._name = "v-scroll-bar";
        this.add(this.vbar);
    }
    draw(g) {
        g.fillBackgroundSize(this.size(), "#aaa");
    }
    set_pref_width(num) {
        this._pref_width = num;
    }
    layout(g, available) {
        this.set_size(new (0, _core.Size)(this._pref_width, 300));
        if (this.hflex()) this.size().w = available.w;
        if (this.vflex()) this.size().h = available.h;
        let ws = this.size().shrink(10);
        this.get_children().forEach((ch)=>{
            if (ch == this.wrapper) ch.layout(g, ws);
            else ch.layout(g, available);
        });
        this.hbar.set_size(new (0, _core.Size)(this.size().w - 20, 20));
        this.hbar.set_position(new (0, _core.Point)(0, this.size().h - this.hbar.size().h));
        this.vbar.set_size(new (0, _core.Size)(20, this.size().h - 20));
        this.vbar.set_position(new (0, _core.Point)(this.size().w - this.vbar.size().w, 0));
        return this.size();
    }
    set_content(view) {
        this.content = view;
        this.wrapper.add(view);
    }
}
class PopupContainer extends (0, _core.BaseParentView) {
    constructor(){
        super((0, _core.gen_id)("popupcontainer"));
        this._name = "popup_container";
    }
    draw(g) {
        g.fillBackgroundSize(this.size(), "gray");
    }
    layout(g, available) {
        let box = this._children[0];
        let size = box.layout(g, new (0, _core.Size)(1000, 1000));
        this.set_size(size);
        return new (0, _core.Size)(size.w, size.h);
    }
    open_at(position) {
        this.set_position(position);
    }
    hide() {
        this._visible = false;
        console.log("hiding", this._visible);
    }
}
class PopupLayer extends LayerView {
    constructor(){
        super((0, _core.gen_id)("popup-layer"));
        this._name = "popup-layer";
    }
    draw(g) {
        if (this._children.length > 0) g.fillBackgroundSize(this.size(), "rgba(255,255,255,0.7)");
    }
    input(event) {
        if (event.type === (0, _core.POINTER_DOWN)) {
            this._children = [];
            event.stopped = true;
        }
    }
    can_receive_mouse() {
        if (this.get_children().length > 0) return true;
        return false;
    }
}
class DialogLayer extends LayerView {
    constructor(){
        super((0, _core.gen_id)("dialog-layer"));
        this._name = "dialog-layer";
    }
    draw(g) {
        if (this._children.length > 0) g.fillBackgroundSize(this.size(), "rgba(255,255,255,0.7)");
    }
}
class DialogContainer extends (0, _core.BaseParentView) {
    constructor(){
        super("dialog-container");
        this._name = "dialog-container";
        this.set_size(new (0, _core.Size)(250, 250));
    }
    draw(g) {
        g.fillBackgroundSize(this.size(), "gray");
    }
    layout(g, available) {
        let box = this._children[0];
        let size = box.layout(g, this.size()) //new Size(600, 600))
        ;
        // this.set_size(size)
        this.set_position(new (0, _core.Point)((g.size().w - size.w) / 2, (g.size().h - size.h) / 2));
        return new (0, _core.Size)(size.w, size.h);
    }
}
class KeystrokeCaptureView extends LayerView {
    constructor(main_view){
        super((0, _core.gen_id)("keystroke_capture_view"));
        this._name = "keystroke-capture-view";
        this.add(main_view);
    }
    input(event) {
        if (event.category === (0, _core.KEYBOARD_CATEGORY)) {
            let kb = event;
            // this.log("got kb", kb)
            if (kb.key === "s" && kb.modifiers.meta === true) {
                // console.log("intercepting save")
                // @ts-ignore
                event.domEvent.preventDefault();
                kb.stopped = true;
            }
            kb.key === "d" && kb.modifiers.meta === true && kb.modifiers.ctrl;
        }
        super.input(event);
    }
}

},{"./core":"6Wpln","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7wzGb":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "randi", ()=>randi);
function randi(min, max) {
    return Math.floor(min + Math.random() * (max - min));
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eaW0r":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "DebugLensGlass", ()=>DebugLensGlass);
parcelHelpers.export(exports, "ResizeHandle", ()=>ResizeHandle);
parcelHelpers.export(exports, "DebugLens", ()=>DebugLens);
parcelHelpers.export(exports, "DebugLayer", ()=>DebugLayer);
var _core = require("./core");
var _canvas = require("./canvas");
var _components = require("./components");
var _containers = require("./containers");
class DebugLensGlass extends (0, _core.BaseView) {
    constructor(p, size){
        super((0, _core.gen_id)("debug-glass"));
        this.lens = p;
        this._name = "debug-lens-glass";
        this.set_size(size);
    }
    layout(g, available) {
        return this.size();
    }
    draw(g) {
        let root = g.root();
        g.ctx.save();
        g.ctx.beginPath();
        let size = this.size();
        g.ctx.rect(0, 0, size.w, size.h);
        g.ctx.clip();
        let trans = g.view_to_local(new (0, _core.Point)(0, 0), this);
        g.ctx.translate(-trans.x, -trans.y);
        this.draw_outline(g, root);
        this.draw_selected(g);
        g.ctx.restore();
    }
    draw_outline(g1, view1) {
        if (view1.name() === "debug-layer") return;
        let pos1 = view1.position();
        let size = view1.size();
        g1.ctx.save();
        if (this.draw_bounds) {
            g1.ctx.strokeStyle = "black";
            g1.ctx.lineWidth = 1;
            for(let s = 1; s < 4; s++){
                g1.ctx.strokeStyle = s % 2 == 0 ? "red" : "black";
                g1.ctx.beginPath();
                g1.ctx.rect(pos1.x + s, pos1.y + s, size.w - s * 2, size.h - s * 2);
                g1.ctx.stroke();
            }
        }
        function draw_debug_text(g, pos, text) {
            let metrics = g.measureText(text, "base");
            g.ctx.save();
            g.ctx.translate(pos.x, pos.y);
            g.ctx.fillStyle = "white";
            g.ctx.fillRect(0, 0, metrics.w + 4, 18);
            g.ctx.strokeStyle = "black";
            g.ctx.lineWidth = 1;
            g.ctx.strokeRect(0, 0, metrics.w + 4, 18);
            g.ctx.fillStyle = "black";
            g.fillStandardText(text, 4, 18, "base");
            g.ctx.restore();
        }
        if (this._draw_names) draw_debug_text(g1, pos1.add(new (0, _core.Point)(5, 5)), view1.name());
        if (this.draw_sizes) {
            let size = view1.size();
            let text = `${size.w.toFixed(1)} x ${size.h.toFixed(1)}`;
            draw_debug_text(g1, pos1.add(new (0, _core.Point)(5, 25)), text);
        }
        if (this.draw_flex) {
            let text = `hflex=${view1.hflex()} vflex=${view1.vflex()}`;
            draw_debug_text(g1, pos1.add(new (0, _core.Point)(5, 35)), text);
        }
        if (this.draw_align) {
            if ("halign" in view1) {
                // @ts-ignore
                let text = `halign=${view1.halign}`;
                draw_debug_text(g1, pos1.add(new (0, _core.Point)(5, 45)), text);
            }
            if ("valign" in view1) {
                // @ts-ignore
                let text = `valign=${view1.valign}`;
                draw_debug_text(g1, pos1.add(new (0, _core.Point)(5, 45)), text);
            }
        }
        function is_parent(view) {
            // @ts-ignore
            return view.is_parent_view && view.is_parent_view();
        }
        function as_parent(view) {
            return view;
        }
        if (is_parent(view1)) {
            let parent = as_parent(view1);
            g1.ctx.save();
            g1.ctx.translate(pos1.x, pos1.y);
            parent.get_children().forEach((ch)=>{
                this.draw_outline(g1, ch);
            });
            g1.ctx.restore();
        }
        g1.ctx.restore();
    }
    draw_names() {
        return this._draw_names;
    }
    set_draw_names(selected) {
        this._draw_names = selected;
    }
    set_draw_sizes(selected) {
        this.draw_sizes = selected;
    }
    set_draw_bounds(selected) {
        this.draw_bounds = selected;
    }
    set_draw_flex(selected) {
        this.draw_flex = selected;
    }
    set_draw_align(selected) {
        this.draw_align = selected;
    }
    input(event) {
        // this.log(event)
        if (event.type === (0, _core.POINTER_DOWN)) {
            let p = event;
            let p2 = event.ctx.view_to_local(p.position, this);
            this.log("global", p2);
            let views = [];
            let should_recurse = (view)=>{
                if (!view.visible()) return false;
                if (view.name() === "debug-layer") return false;
                if (view.name() === "debug-lens") return false;
                return true;
            };
            let should_include = (view)=>{
                if (view.name() === "dialog-layer") return false;
                if (view.name() === "debug-layer") return false;
                if (view.name() === "popup-layer") return false;
                if (view.name() === "debug-lens") return false;
                if (view.name() === "debug-lens-glass") return false;
                return true;
            };
            this.pick_under_cursor(event.ctx.root(), p2, views, should_recurse, should_include);
            this.log("path is", views);
            this.lens.set_selected(views[views.length - 1]);
        }
    }
    pick_under_cursor(view, cursor, views, should_recurse, should_include) {
        if (!should_recurse(view)) return;
        if (view.size().contains(cursor) && should_include(view)) views.push(view);
        // @ts-ignore
        if (view.is_parent_view && view.is_parent_view()) {
            let parent = view;
            // this.log("going into parent",view.name())
            let chs = parent.get_children();
            chs.forEach((ch)=>{
                this.pick_under_cursor(ch, cursor.subtract(ch.position()), views, should_recurse, should_include);
            });
        }
    }
    draw_selected(g) {
        if (!this.lens._selected) return;
        let trans = g.view_to_local(new (0, _core.Point)(0, 0), this.lens._selected);
        // this.log("trans",trans)
        // this.log("selected is", this._selected.name())
        // let me_trans = g.view_to_local(new Point(0,0,),this)
        // this.log("me_trans = ", me_trans)
        let rect = (0, _canvas.rect_from_pos_size)(trans, this.lens._selected.size());
        g.stroke(rect, "red");
    }
}
class ResizeHandle extends (0, _core.BaseView) {
    constructor(lens){
        super((0, _core.gen_id)("debug-lens-resize"));
        this._name = "debug-lens-resize-handle";
        this.lens = lens;
        this.set_size(new (0, _core.Size)(20, 20));
    }
    input(event) {
        if (event.category === (0, _core.POINTER_CATEGORY)) {
            let pt = event;
            if (event.type === (0, _core.POINTER_DRAG)) this.lens.set_size(this.lens.size().add(pt.delta));
            event.stopped = true;
            event.ctx.repaint();
        }
    }
    draw(g) {
        g.fillBackgroundSize(this.size(), "#888");
        g.draw_glyph(2921, 2, 0, "base", "black");
    }
    layout(g, available) {
        return this.size();
    }
}
class DebugPropSheet extends (0, _core.BaseParentView) {
    constructor(lens){
        super("debug-prop-sheet");
        this.lens = lens;
        this.lens.on("select", ()=>this.rebuild());
        this.vbox = new (0, _containers.VBox)();
        this.add(this.vbox);
    }
    draw(g) {
        g.fillBackgroundSize(this.size(), "white");
    }
    layout(g, available) {
        this.get_children().forEach((ch)=>{
            ch.layout(g, available);
        });
        this.set_size(new (0, _core.Size)(this.vbox.size().w, this.vbox.size().h));
        return this.size();
    }
    rebuild() {
        let sel = this.lens._selected;
        this.log("rebuilding prop sheet for ", sel);
        this.vbox.clear_children();
        this.vbox.add(new (0, _components.Label)("id"));
        // @ts-ignore
        this.vbox.add(new (0, _components.Label)(sel.id));
        this.vbox.add(new (0, _components.Label)("name"));
        this.vbox.add(new (0, _components.Label)(sel.name()));
        this.vbox.add(new (0, _components.Label)(`hflex: ${sel.hflex()}`));
        this.vbox.add(new (0, _components.Label)(`vflex: ${sel.vflex()}`));
        this.vbox.add(new (0, _components.Label)(`size: ${sel.size().toString()}`));
    }
}
class DebugLens extends (0, _core.BaseParentView) {
    constructor(){
        super((0, _core.gen_id)("debug-lens"));
        this._name = "debug-lens";
        this.set_size(new (0, _core.Size)(400, 300));
        let vbox = new (0, _containers.VBox)();
        vbox.set_name("debug-lens-vbox");
        vbox.halign = "left";
        this.vbox = vbox;
        this.sidebar_right = false;
        this.sidebar_width = 200;
        vbox.add((0, _core.with_change)(new (0, _components.ToggleButton)("right"), (e)=>this.sidebar_right = !this.sidebar_right));
        vbox.add((0, _core.with_change)(new (0, _components.ToggleButton)("names"), (e)=>this.glass.set_draw_names(e.target.selected)));
        vbox.add((0, _core.with_change)(new (0, _components.ToggleButton)("bounds"), (e)=>this.glass.set_draw_bounds(e.target.selected)));
        this.propsheet = new DebugPropSheet(this);
        vbox.add(this.propsheet);
        this.add(vbox);
        this.glass = new DebugLensGlass(this, this.size());
        this.add(this.glass);
        this.resize_handle = new ResizeHandle(this);
        this.add(this.resize_handle);
    }
    input(event) {
        event.type;
        if (event.type === (0, _core.POINTER_DRAG)) {
            if (event.target !== this) return;
            this.set_position(this.position().add(event.delta));
            event.ctx.repaint();
        }
    }
    can_receive_mouse() {
        return true;
    }
    draw(g) {
        g.ctx.save();
        g.ctx.fillStyle = "#a0a0a0";
        let s = this.size();
        g.ctx.fillRect(0, 0, s.w, 20);
        if (this.sidebar_right) {
            g.ctx.fillRect(0, 0, 20, s.h);
            g.ctx.fillRect(s.w - this.sidebar_width, 0, this.sidebar_width, s.h);
            g.ctx.strokeRect(20, 20, this.size().w - this.sidebar_width - 20, this.size().h - 20 - 20);
        } else {
            g.ctx.fillRect(0, 0, this.sidebar_width, s.h);
            g.ctx.fillRect(s.w - 20, 0, 20, s.h);
            g.ctx.strokeRect(this.sidebar_width, 20, this.size().w - this.sidebar_width - 20, this.size().h - 20 - 20);
        }
        g.ctx.fillRect(0, s.h - 20, s.w, 20);
        g.ctx.strokeStyle = "#444";
        g.ctx.strokeRect(0, 0, this.size().w, this.size().h);
        g.fillStandardText("debug lens", 10, 20, "base");
        let txt = `size: ${this.glass.size().w} x ${this.glass.size().h}`;
        let metrics = g.measureText(txt, "base");
        g.fillStandardText(txt, (this.size().w - metrics.w) / 2, this.size().h, "base");
        g.ctx.restore();
    }
    layout(g, available) {
        this.get_children().forEach((ch)=>{
            ch.layout(g, available);
        });
        let s = this.size();
        if (this.sidebar_right) {
            this.vbox.set_position(new (0, _core.Point)(s.w - this.sidebar_width, 20));
            this.glass.set_position(new (0, _core.Point)(20, 20));
        } else {
            this.vbox.set_position(new (0, _core.Point)(0, 20));
            this.glass.set_position(new (0, _core.Point)(this.sidebar_width, 20));
        }
        this.glass.set_size(new (0, _core.Size)(s.w - this.sidebar_width - 20, s.h - 20 - 20));
        this.resize_handle.set_position(new (0, _core.Point)(s.w - 20, s.h - 20));
        return this.size();
    }
    set_visible(b) {
        this._visible = b;
    }
    set_selected(view) {
        this._selected = view;
        this.fire("select", this._selected);
    }
}
class DebugLayer extends (0, _containers.LayerView) {
    constructor(){
        super("debug-layer");
        this._name = "debug-layer";
        let dl = new DebugLens();
        dl.set_visible(false);
        this.add(dl);
        this.button = new (0, _components.ToggleButton)("D");
        this.button.on((0, _core.COMMAND_CHANGE), ()=>{
            dl.set_visible(!dl.visible());
        });
        this.add(this.button);
    }
    layout(g, available) {
        this.button.layout(g, available);
        super.layout(g, available);
        let s = this.size();
        let b = this.button.size();
        this.button.set_position(new (0, _core.Point)(s.w - b.w, s.h - b.h));
        return this.size();
    }
}

},{"./core":"6Wpln","./canvas":"1Z0N5","./components":"563zL","./containers":"kfq5H","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lXFYo":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "TableView", ()=>TableView);
var _core = require("./core");
var _containers = require("./containers");
class TableHeaderView extends (0, _core.BaseView) {
    constructor(table){
        super((0, _core.gen_id)("table-header-view"));
        this.table = table;
        this._name = "table-header-view";
    }
    draw(g) {
        g.fillBackgroundSize(this.size(), "#f0f0f0");
        // this.log("drawing",this.size())
        let x = 0;
        let y = 20;
        this.table.columns_keys.forEach((key, k)=>{
            let tx = x + 0;
            g.fillRect(tx, 0, 1, 20, "black");
            g.fillStandardText(key, tx + 5, y, "base");
            x += this.table.columns_widths[k];
        });
    }
    layout(g, available) {
        this.set_size(new (0, _core.Size)(available.w, 20));
        return this.size();
    }
}
class TableGridView extends (0, _core.BaseView) {
    constructor(table){
        super((0, _core.gen_id)("table-grid-view"));
        this._name = "table-grid-view";
        this.table = table;
    }
    draw(g) {
        let h = 20;
        let gw = this.size().w;
        for(let i = 0; i < this.table.data.length; i++){
            let row = this.table.data[i];
            let y = i * h;
            let x = 0;
            this.table.columns_keys.forEach((key, k)=>{
                let col_width = this.table.columns_widths[k];
                let tx = x;
                g.fillRect(tx, y, 1, 20, "black");
                g.fillRect(tx, y, gw, 1, "black");
                let txt = row[key];
                let m = g.measureText(txt, "base");
                if (m.w > col_width) g.fillRect(tx, y, col_width, 20, "red");
                g.fillStandardText(txt, tx + 5, y + 20, "base");
                x += col_width;
            });
        }
    }
    layout(g, available) {
        this.set_size(new (0, _core.Size)(available.w, this.table.data.length * 20));
        return this.size();
    }
}
class TableView extends (0, _core.BaseParentView) {
    constructor(songs, columns_keys, columns_widths){
        super((0, _core.gen_id)("table-view"));
        this.data = songs;
        this.columns_keys = columns_keys;
        this.columns_widths = columns_widths;
        this.header = new TableHeaderView(this);
        this.add(this.header);
        this.scroll = new (0, _containers.ScrollView)();
        this.scroll.set_hflex(true);
        this.scroll.set_vflex(true);
        this.add(this.scroll);
        this.grid = new TableGridView(this);
        this.scroll.set_content(this.grid);
        this.set_hflex(true);
        this.set_vflex(true);
    }
    draw(g) {
        super.draw(g);
    }
    layout(g, available) {
        // this.log('layout. avail',available)
        if (this.hflex && this.vflex) this.set_size(available);
        else this.set_size(new (0, _core.Size)(200, 200));
        // layout header
        this.header.layout(g, this.size());
        let s2 = new (0, _core.Size)(this.size().w, this.size().h - 20);
        this.scroll.layout(g, s2);
        this.scroll.set_position(new (0, _core.Point)(0, 20));
        // layout scroll view
        // layout the grid?
        return this.size();
    }
}

},{"./core":"6Wpln","./containers":"kfq5H","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}]},["9iQi8","c3nm2"], "c3nm2", "parcelRequirec94a")

</script>
</body>
</html>
